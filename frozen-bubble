#!/usr/bin/perl
#*****************************************************************************
#
#                          Frozen-Bubble
#
# Copyright (c) 2000, 2001, 2002, 2003, 2004 The Frozen-Bubble Team
#
# Sponsored by MandrakeSoft <http://www.mandrakesoft.com/>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#
#******************************************************************************
#
# Design & Programming by Guillaume Cottenceau between Oct 2001 and Jan 2002.
# Level Editor parts by Kim Joham and David Joham between Oct 2002 and Jan 2003.
# Network game by Guillaume Cottenceau in 2004.
#
# Check official home: http://www.frozen-bubble.org/
#
#******************************************************************************
#
#
# Yes it uses Perl, you non-believer :-).
#

#use diagnostics;
use strict;

use vars qw($TARGET_ANIM_SPEED $BUBBLE_SIZE $ROW_SIZE $LAUNCHER_SPEED $BUBBLE_SPEED $MALUS_BUBBLE_SPEED $TIME_APPEARS_NEW_ROOT
            %POS %POS_1P %POS_2P %MENUPOS $KEYS %actions %angle %pdata $app $font %apprects $event %rects %sticked_bubbles %root_bubbles
            $background $background_orig @bubbles_images $gcwashere %bubbles_anim %launched_bubble %tobe_launched %next_bubble
            $shooter $sdl_flags $mixer $mixer_enabled $music_disabled $sfx_disabled @playlist %sound %music %pinguin %canon
            $graphics_level @update_rects $CANON_ROTATIONS_NB %malus_bubble %falling_bubble %exploding_bubble %malus_gfx
            %sticking_bubble $version $time %imgbin $TIME_HURRY_WARN $TIME_HURRY_MAX $TIMEOUT_PINGUIN_SLEEP $FREE_FALL_CONSTANT
            $direct @PLAYERS @ALL_PLAYERS %levels $display_on_app_disabled $total_time $time_1pgame $fullscreen $rcfile $hiscorefile $HISCORES
            $lev_number $playermalus $loaded_levelset $direct_levelset $chainreaction %chains %history %img_mini $frame $sock $gameserver);

use Data::Dumper;

use SDL;
use SDL::App;
use SDL::Surface;
use SDL::Event;
use SDL::Cursor;
use SDL::Font;
use SDL::Mixer;

use fb_stuff;
use fb_net;
use fbsyms;
use FBLE;

$| = 1;

$TARGET_ANIM_SPEED = 20;        # number of milliseconds that should last between two animation frames
$LAUNCHER_SPEED = 0.03;		# speed of rotation of launchers
$BUBBLE_SPEED = 10;		# speed of movement of launched bubbles
$MALUS_BUBBLE_SPEED = 30;	# speed of movement of "malus" launched bubbles
$CANON_ROTATIONS_NB = 40;       # number of rotations of images for canon (should be consistent with gfx/shoot/Makefile)

$TIMEOUT_PINGUIN_SLEEP = 200;
$FREE_FALL_CONSTANT = 0.5;
$KEYS = { p1 => { left => SDLK_x,    right => SDLK_v,     fire => SDLK_c,  center => SDLK_d },
	  p2 => { left => SDLK_LEFT, right => SDLK_RIGHT, fire => SDLK_UP, center => SDLK_DOWN },
	  misc => { fs => SDLK_f } };

$sdl_flags = SDL_ANYFORMAT | SDL_HWSURFACE | SDL_DOUBLEBUF | SDL_HWACCEL | SDL_ASYNCBLIT;
$mixer = 0;
$graphics_level = 3;
@PLAYERS = qw(p1 p2);
@ALL_PLAYERS = qw(p1 p2 rp1 rp2 rp3 rp4);
$playermalus = 0;
$chainreaction = 0;

$rcfile = "$ENV{HOME}/.fbrc";
eval(cat_($rcfile));
eval(cat_($hiscorefile = "$ENV{HOME}/.fbhighscores"));
$version = '2.0.0';

print "        [[ Frozen-Bubble-$version ]]\n\n";
print '  http://www.frozen-bubble.org/

  Copyright (c) 2000, 2001, 2002, 2003, 2004 The Frozen-Bubble Team.
 
    Artwork: Alexis Younes
             Amaury Amblard-Ladurantie
    Soundtrack: Matthias Le Bidan
    Design & Programming: Guillaume Cottenceau
    Level Editor: Kim and David Joham

  Sponsored by MandrakeSoft <http://www.mandrakesoft.com/>

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License version 2, as
  published by the Free Software Foundation.

';

local $_ = "@ARGV";

/-h/ and die "Usage: ", basename($0), " [OPTION]...
  -h, --help                 display this help screen
 -fs, --fullscreen           start in fullscreen mode
 -ns, --nosound              don't try to start any sound stuff
 -nm, --nomusic              disable music (only)
 -nfx, --nosfx               disable sound effects (only)
      --playlist<file>       use all files listed in the given file as music files and play them
      --playlist<directory>  use all files inside the given directory as music files and play them
 -sl, --slow_machine         enable slow machine mode (disable a few animations)
 -vs, --very_slow_machine    enable very slow machine mode (disable all that can be disabled)
 -di, --direct               directly start (2p) game (don't display menu)
 -so, --solo                 directly start solo (1p) game, with random levels if no -l<#n> is given
 -cr, --chain_reaction       enable chain-reaction
 -l<#n>, --level<#n>         directly start the n-th level
 -cb, --colourblind          use bubbles for colourblind people
 -pm<#n>, --playermalus<#n>  add a malus of n to the left player (can be negative)
 -ls<name>, --levelset<name> directly start with the specified levelset name
 -ms<url>, --masterserver<url> use the specified URL to fetch the serverlist from
 -gs<host:port>, --gameserver<host:port> try to use the specified host and port as game server

";

/-fs/ || /-fu/ and $fullscreen = 1;
/-ns/ || /-noso/ and $mixer = 'SOUND_DISABLED';
/-nm/ || /-nom/ and $music_disabled = 1;
/-nfx/ || /-nosf/ and $sfx_disabled = 1;
/-playlist\s*(\S+)/ and @playlist = -d $1 ? glob("$1/*") : cat_($1);
/-sl/ and $graphics_level = 2;
/-vs/ || /-ve/ and $graphics_level = 1;
/-srand/ and srand 0;
/-di/ and $direct = 1;
/-so/ and $direct = 1, @PLAYERS = ('p1');
/-cr/ || /-chain_reaction/ and $chainreaction = 1;
/-cb/ || /-co/ and $colourblind = 1;
/-pm\s*(-?[\d]+)/ || /-playermalus\s*(-?\d+)/ and $playermalus = $1;
/-ls\s*(\S+)/ || /-levelset\s*(\S+)/ and $levels{current} = 1, $direct = 1, @PLAYERS = ('p1'), $direct_levelset = $1;
/-l\s*(\d+)/ || /-level\s*(\d+)/ and $levels{current} = $1, $direct = 1, @PLAYERS = ('p1');
/-ms\s*(\S+)/ || /-masterserver\s*(\S+)/ and $fb_net::masterserver = $1;
/-gs\s*(\S+):(\S+)/ || /-gameserver\s*(\S+):(\S+)/ and $gameserver = "$1:$2";
/-mp(\S+),(\S+)/ and do {
    my $mynick = $$;
    my $nb = $2;
    my $ping = fb_net::connect($1, 1511);
    if (!$ping) {
        die "can't proceed then\n";
    }
    my ($free, @games) = fb_net::list();
    my $ok;
    if (@games) {
        $ok = fb_net::join($games[0][0], $mynick);
    } else {
        $ok = fb_net::create($mynick);
    }
    while (1) {
        print "Waiting for $nb players before starting...\n";
        sleep 1;
        fb_net::send_('STATUS');
        my @players = split /,/, fb_net::readline_();
        last if @players == $nb;
    }

    fb_net::send_('START');

    @PLAYERS = qw(p1);
    my @mappings = fb_net::wait4start();
    foreach my $m (@mappings) {
        my $player;
        if ($m->{nick} eq $mynick) {
            $player = 'p1';
        } else {
            foreach my $p (qw(rp1 rp2 rp3 rp4)) {
                exists $pdata{$p}{id} or $player ||= $p;
            }
            push @PLAYERS, $player;
        }
        $pdata{$player}{id} = $m->{id};
        $pdata{$player}{nick} = $m->{nick};
        $pdata{id2p}{$m->{id}} = $player;
        print "$player is: $m->{nick}\n";
    }
    
};

#- ------------------------------------------------------------------------

END {
    if ($app) {
	$total_time = ($app->ticks - $total_time)/1000;
	my $h = int($total_time/3600);
	my $m = int(($total_time-$h*3600)/60);
	my $s = int($total_time-$h*3600-$m*60);
	print "\nAddicted for ", $h ? "$h"."h " : "", $m ? "$m"."m " : "", "$s"."s.\n";
    }
}

#- it doesn't keep ordering (but I don't care)
sub fastuniq { my %l; @l{@_} = @_; values %l }


#- ----------- sound related stuff ----------------------------------------

sub play_sound($) {
    $mixer_enabled && $mixer && !$sfx_disabled && $sound{$_[0]} and $mixer->play_channel(-1, $sound{$_[0]}, 0);
}

sub play_music($;$) {
    my ($name, $pos) = @_;
    $mixer_enabled && $mixer && !$music_disabled or return;
    @playlist && $mixer->playing_music and return;
    $app->delay(10) while $mixer->fading_music;   #- mikmod will deadlock if we try to fade_out while still fading in
    $mixer->playing_music and $mixer->fade_out_music(500); $app->delay(400);
    $app->delay(10) while $mixer->playing_music;  #- mikmod will segfault if we try to load a music while old one is still fading out
    my %musics = (intro => '/snd/introzik.xm', main1p => '/snd/frozen-mainzik-1p.xm', main2p => '/snd/frozen-mainzik-2p.xm');
    my $mus if 0;                                 #- I need to keep a reference on the music or it will be collected at the end of this function, thus I manually collect previous music
    if (@playlist) {
	my $tryanother = sub {
	    my $elem = chomp_(shift @playlist);
	    $elem or return -1;
	    -f $elem or return 0;
	    push @playlist, $elem;
	    $mus = SDL::Music->new($elem);
	    if ($mus->{-data}) {
		print STDERR "[Playlist] playing `$elem'\n";
		$mixer->play_music($mus, 0);
		return 1;
	    } else { 
		print STDERR "Warning, could not create new music from `$elem' (reason: ", $app->error, ").\n";
		return 0;
	    }
	};
	while ($tryanother->() == 0) {};
    } else {
	$mus = SDL::Music->new("$FPATH$musics{$name}");
	$mus->{-data} or print STDERR "Warning, could not create new music from `$FPATH$musics{$name}' (reason: ", $app->error, ").\n";
	if ($pos) {
	    fb_c_stuff::fade_in_music_position($mus->{-data}, -1, 500, $pos);
	} else {
	    $mixer->play_music($mus, -1);
	}
        $music{current} = $name;
    }
}

sub init_sound() {
    $mixer = eval { SDL::Mixer->new(-frequency => 44100, -channels => 2, -size => 1024); };
    if ($@) {
	$@ =~ s| at \S+ line.*\n||;
	print STDERR "\nWarning: can't initialize sound (reason: $@).\n";
	return 0;
    }
    print "[Sound Init]\n";
    my @sounds = qw(stick destroy_group newroot newroot_solo lose hurry pause menu_change menu_selected rebound launch malus noh snore cancel typewriter applause);
    foreach (@sounds) {
	my $sound_path = "$FPATH/snd/$_.wav";
	$sound{$_} = SDL::Sound->new($sound_path);
	if ($sound{$_}{-data}) {
	    $sound{$_}->volume(80);
	} else {
	    print STDERR "Warning, could not create new sound from `$sound_path'.\n";
	}
    }
    return 1;
}


#- ----------- graphics related stuff --------------------------------------

sub add_default_rect($) {
    my ($surface) = @_;
    $rects{$surface} = SDL::Rect->new(-width => $surface->width, -height => $surface->height);
}

sub translate_mini_image {
    my ($image) = @_;
    if ($::p_ =~ /rp/ || ($::p_ eq '' && $::p =~ /rp/)) {
        $img_mini{$image} and return $img_mini{$image};
    }
    return $image;
}

sub put_image($$$) {
    my ($image, $x, $y) = @_;
    $image = translate_mini_image($image);
    $rects{$image} or die "please don't call me with no rects\n".backtrace();
    my $drect = SDL::Rect->new(-width => $image->width, -height => $image->height, -x => $x, '-y' => $y);
    $image->blit($rects{$image}, $app, $drect);
    push @update_rects, $drect;
}

sub erase_image_from($$$$) {
    my ($image, $x, $y, $img) = @_;
    $image = translate_mini_image($image);
    my $drect = SDL::Rect->new(-width => $image->width, -height => $image->height, -x => $x, '-y' => $y);
    $img->blit($drect, $app, $drect);
    push @update_rects, $drect;
}

sub erase_image($$$) {
    my ($image, $x, $y) = @_;
    erase_image_from($image, $x, $y, $background);
}

sub put_image_to_background($$$) {
    my ($image, $x, $y) = @_;
    my $drect;
    $image = translate_mini_image($image);
    ($x == 0 && $y == 0) and print "put_image_to_background: warning, X and Y are 0\n";
    if ($y > 0) {
	$drect = SDL::Rect->new(-width => $image->width, -height => $image->height, -x => $x, '-y' => $y);
	$display_on_app_disabled or $image->blit($rects{$image}, $app, $drect);
	$image->blit($rects{$image}, $background, $drect);
    } else {  #- clipping seems to not work when from one Surface to another Surface, so I need to do clipping by hand
	$drect = SDL::Rect->new(-width => $image->width, -height => $image->height + $y, -x => $x, '-y' => 0);
	my $irect = SDL::Rect->new(-width => $image->width, -height => $image->height + $y, '-y' => -$y);
	$display_on_app_disabled or $image->blit($irect, $app, $drect);
	$image->blit($irect, $background, $drect);
    }
    push @update_rects, $drect;
}

sub remove_image_from_background($$$) {
    my ($image, $x, $y) = @_;
    $image = translate_mini_image($image);
    ($x == 0 && $y == 0) and print "remove_image_from_background: warning, X and Y are 0\n";
    my $drect = SDL::Rect->new(-width => $image->width, -height => $image->height, -x => $x, '-y' => $y);
    $background_orig->blit($drect, $background, $drect);
    $background_orig->blit($drect, $app, $drect);
    push @update_rects, $drect;
}

sub remove_images_from_background {
    my ($player, @images) = @_;
    foreach my $image (@images) {
	($image->{'x'} == 0 && $image->{'y'} == 0) and print "remove_images_from_background: warning, X and Y are 0\n";
        my $img = translate_mini_image($image->{img});
	my $drect = SDL::Rect->new(-width => $img->width, -height => $img->height, -x => $image->{'x'}, '-y' => $image->{'y'});
	$background_orig->blit($drect, $background, $drect);
	$background_orig->blit($drect, $app, $drect);
	push @update_rects, $drect;
    }
}

sub put_allimages_to_background($) {
    my ($player) = @_;
    put_image_to_background($_->{img}, $_->{'x'}, $_->{'y'}) foreach @{$sticked_bubbles{$player}};
}

sub switch_image_on_background($$$;$) {
    my ($image, $x, $y, $save) = @_;
    my $drect = SDL::Rect->new(-width => $image->width, -height => $image->height, -x => $x, '-y' => $y);
    if ($save) {
	$save = SDL::Surface->new(-width => $image->width, -height => $image->height, -depth => 32, -Amask => "0 but true");  #- grrr... this piece of shit of Amask made the surfaces slightly modify along the print/erase of "Hurry" and "Pause".... took me so much time to debug and find that the problem came from a bug when Amask is set to 0xFF000000 (while it's -supposed- to be set to 0xFF000000 with 32-bit graphics!!)
	$background->blit($drect, $save, $rects{$image});
    }
    $image->blit($rects{$image} || SDL::Rect->new(-width => $image->width, -height => $image->height), $background, $drect);
    $background->blit($drect, $app, $drect);
    push @update_rects, $drect;
    return $save;
}

sub add_image($) {
    my $file = "$FPATH/gfx/$_[0]";
    my $img = SDL::Surface->new(-name => $file);
    $img->{-surface} or die "FATAL: Couldn't load `$file' into a SDL::Surface.\n";
    add_default_rect($img);
    return $img;
}

sub add_bubble_image($) {
    my ($file) = @_;
    my $bubble = add_image($file);
    push @bubbles_images, $bubble;
    return $bubble;
}


#- ----------- generic game stuff -----------------------------------------

sub iter_players(&) {
    my ($f, @p) = @_;
    @p == 0 and @p = @PLAYERS;
    local $::p;
    foreach $::p (@p) {
        $::p !~ /rp/ and goto normal_sizes;  #- can't use an if block because of local
        local $BUBBLE_SIZE = $BUBBLE_SIZE / 2;
        local $BUBBLE_SPEED = $BUBBLE_SPEED / 2;
        local $ROW_SIZE = $ROW_SIZE / 2;
	local $FREE_FALL_CONSTANT = $FREE_FALL_CONSTANT / 2;
      normal_sizes:
	&$f;
    }
}
sub iter_players_(&) {  #- so that I can do an iter_players_ from within an iter_players
    my ($f) = @_;
    local $::p_;
    foreach $::p_ (@PLAYERS) {
	&$f;
    }
}
sub iter_players_but_first(&) {
    my ($f) = @_;
    my (undef, @p) = @PLAYERS;
    &iter_players($f, @p);
}
sub iter_local_players(&) {
    my ($f) = @_;
    my @p = grep { !/rp/ } @PLAYERS;
    &iter_players($f, @p);
}
sub iter_distant_players(&) {
    my ($f) = @_;
    my @p = grep { /rp/ } @PLAYERS;
    &iter_players($f, @p);
}

sub is_1p_game() { @PLAYERS == 1 }
sub is_mp_game() { any { /rp/ } @PLAYERS }
sub is_2p_game() { @PLAYERS == 2 && !is_mp_game() }

sub is_leader() {
    my $mynick = $pdata{p1}{nick};
    my $is_leader = 1;
    iter_players_but_first {
        $is_leader &&= $pdata{$::p}{nick} gt $mynick;
    };
    return $is_leader;
}
sub is_local_player($) {
    my ($player) = @_;
    $player !~ /rp/;
}
sub is_distant_player($) {
    my ($player) = @_;
    $player =~ /rp/;
}

sub mp_propagate($$) {
    my ($key, $value) = @_;
    if (is_leader()) {
        fb_net::gsend("$key:$value");
        return $value;
    } else {
        my $m = fb_net::grecv_get1msg();
        if ($m->{msg} !~ /^\Q$key:\E(.+)/) {
            print "Network protocol error.\n";
            return;
        } else {
            return $1;
        }
    }
}

sub living_players() {
    my @living;
    iter_players_ {
        if ($pdata{$::p_}{state} eq 'ingame') {
            push @living, $::p_;
        }
    };
    return @living;
}

#- ----------- bubble game stuff ------------------------------------------

sub calc_real_pos_given_arraypos($$$) {
    my ($cx, $cy, $player) = @_;
    ($POS{$player}{left_limit} + $cx * $BUBBLE_SIZE + odd($cy+$pdata{$player}{oddswap}) * $BUBBLE_SIZE/2,
     $POS{$player}{top_limit} + $cy * $ROW_SIZE);
}

sub calc_real_pos($$) {
    my ($b, $player) = @_;
    ($b->{'x'}, $b->{'y'}) = calc_real_pos_given_arraypos($b->{cx}, $b->{cy}, $player);
}

sub get_array_yclosest($$) {
    my ($y, $player) = @_;
    return int(($y-$POS{$player}{top_limit}+$ROW_SIZE/2) / $ROW_SIZE);
}

sub get_array_closest_pos($$$) { # roughly the opposite than previous function
    my ($x, $y, $player) = @_;
    my $ny = get_array_yclosest($y, $player);
    my $nx = int(($x-$POS{$player}{left_limit}+$BUBBLE_SIZE/2 - odd($ny+$pdata{$player}{oddswap})*$BUBBLE_SIZE/2)/$BUBBLE_SIZE);
    return ($nx, $ny);
}

sub is_collision($$$) {
    my ($bub, $x, $y) = @_;
    my $DISTANCE_COLLISION_SQRED = sqr($BUBBLE_SIZE * 0.82);
    my $xs = sqr($bub->{x} - $x);
    ($xs > $DISTANCE_COLLISION_SQRED) and return 0; 
    return ($xs + sqr($bub->{'y'} - $y)) < $DISTANCE_COLLISION_SQRED;
}

sub create_bubble_given_img($) {
    my ($img) = @_;
    my %bubble;
    ref($img) eq 'SDL::Surface' or die "<$img> seems to not be a valid image\n" . backtrace();
    $bubble{img} = $img;
    return \%bubble;
}

sub create_bubble_given_img_num($) {
    my ($num) = @_;
    return create_bubble_given_img($bubbles_images[$num]);
}

sub validate_nextcolor($$) {
    my ($num, $player) = @_;
    return !is_1p_game() || member($num, map { get_bubble_num($_) } @{$sticked_bubbles{$player}});
}

sub each_index(&@) {
    my $f = shift;
    local $::i = 0;
    foreach (@_) {
	$f->();
	$::i++;
    }
}
sub get_bubble_num {
    my ($b) = @_;
    my $num = -1;
    each_index { $_ eq $b->{img} and $num = $::i } @bubbles_images;
    return $num;
}

sub iter_rowscols(&$) {
    my ($f, $oddswap) = @_;
    local $::row; local $::col;
    foreach $::row (0 .. 11) {
	foreach $::col (0 .. 7 - odd($::row+$oddswap)) {
	    &$f;
	}
    }
}

sub each_index(&@) {
    my $f = shift;
    local $::i = 0;
    foreach (@_) {
	&$f($::i);
	$::i++;
    }
}
sub img2numb { my ($i, $f) = @_; each_index { $i eq $_ and $f = $::i } @bubbles_images; return defined($f) ? $f : '-' }

#sub history {
#    foreach my $frame (@{$history{$_[0]}}[-10...1]) {
#	iter_rowscols {
#	    if ($::col == 0) {
#		$::row == 0 or print "\n";
#		odd($::row+$frame->{oddswap}) and print "  ";
#	    }
#	    foreach (@{$frame->{sticked}}) {
#		$_->[0] == $::col && $_->[1] == $::row or next;
#		print $_->[2];
#		goto non_void;
#	    }
#	    if ($frame->{sticking}[0] == $::col && $frame->{sticking}[1] == $::row) {
#		print "\033[D!$frame->{sticking}[2]";
#		goto non_void;
#	    }
#	    print '-';
#	  non_void:
#	    $::col+odd($::row+$frame->{oddswap}) < 7 and print "   ";
#        } $frame->{oddswap};
#	print "\n\n";
#    }
#}

sub bubble_next_to($$$$$) {
    my ($x1, $y1, $x2, $y2, $player) = @_;
    $x1 == $x2 && $y1 == $y2 and die "bubble_next_to: assert failed -- same bubbles ($x1:$y1;$player)" . backtrace();
#    $x1 == $x2 && $y1 == $y2 and history($player), die "bubble_next_to: assert failed -- same bubbles ($x1:$y1;$player)" . backtrace();
    return to_bool((sqr($x1+odd($y1+$pdata{$player}{oddswap})*0.5 - ($x2+odd($y2+$pdata{$player}{oddswap})*0.5)) + sqr($y1 - $y2)) < 3);
}

sub next_positions($$) {
    my ($b, $player) = @_;
    my $validate_pos = sub {
	my ($x, $y) = @_;
	if_($x >= 0 && $x+odd($y+$pdata{$player}{oddswap}) <= 7 && $y >= 0 && $y >= $pdata{$player}{newrootlevel} && $y <= 11,
	    [ $x, $y ]);
    };
    ($validate_pos->($b->{cx} - 1, $b->{cy}),
     $validate_pos->($b->{cx} + 1, $b->{cy}),
     $validate_pos->($b->{cx} - even($b->{cy}+$pdata{$player}{oddswap}), $b->{cy} - 1),
     $validate_pos->($b->{cx} - even($b->{cy}+$pdata{$player}{oddswap}), $b->{cy} + 1),
     $validate_pos->($b->{cx} - even($b->{cy}+$pdata{$player}{oddswap}) + 1, $b->{cy} - 1),
     $validate_pos->($b->{cx} - even($b->{cy}+$pdata{$player}{oddswap}) + 1, $b->{cy} + 1));
}

#- bubble ends its life sticked somewhere
sub real_stick_bubble {
    my ($bubble, $xpos, $ypos, $player, $neighbours_ok) = @_;
    $bubble->{cx} = $xpos;
    $bubble->{cy} = $ypos;
    foreach (@{$sticked_bubbles{$player}}) {
	if (bubble_next_to($_->{cx}, $_->{cy}, $bubble->{cx}, $bubble->{cy}, $player)) {
	    push @{$_->{neighbours}}, $bubble;
	    $neighbours_ok or push @{$bubble->{neighbours}}, $_;
	}
    }
    push @{$sticked_bubbles{$player}}, $bubble;
    $bubble->{cy} == $pdata{$player}{newrootlevel} and push @{$root_bubbles{$player}}, $bubble;
    calc_real_pos($bubble, $player);
    put_image_to_background($bubble->{img}, $bubble->{'x'}, $bubble->{'y'});
}

sub destroy_bubbles {
    my ($player, @bubz) = @_;
    $graphics_level == 1 and return;
    foreach (@bubz) {
	$_->{speedx} = (rand(3)-1.5) / ($player =~ /rp/ ? 2 : 1);
	$_->{speedy} = (-rand(4)-2) / ($player =~ /rp/ ? 2 : 1);
    }
    push @{$exploding_bubble{$player}}, @bubz;
}

sub find_bubble_group($) {
    my ($b) = @_;
    my @neighbours = $b;
    my @group;
    while (1) {
	push @group, @neighbours;
	@neighbours = grep { $b->{img} eq $_->{img} && !member($_, @group) } fastuniq(map { @{$_->{neighbours}} } @neighbours);
	last if !@neighbours;
    }
    @group;
}

sub stick_bubble($$$$$) {
    my ($bubble, $xpos, $ypos, $player, $count_for_root) = @_;
    my @falling;
    my $need_redraw = 0;
    @{$bubble->{neighbours}} = grep { bubble_next_to($_->{cx}, $_->{cy}, $xpos, $ypos, $player) } @{$sticked_bubbles{$player}};

    #- in multiple chain reactions, it's possible that the group doesn't exist anymore in some rare situations :/
    exists $bubble->{chaindestx} && !@{$bubble->{neighbours}} and return;

    my @will_destroy = difference2([ find_bubble_group($bubble) ], [ $bubble ]);

    if (@will_destroy <= 1) {
	#- stick
	play_sound('stick');
	real_stick_bubble($bubble, $xpos, $ypos, $player, 1);
	$sticking_bubble{$player} = $bubble;
	$pdata{$player}{sticking_step} = 0;
    } else {
	#- destroy the group
	play_sound('destroy_group');
	foreach my $b (difference2([ fastuniq(map { @{$_->{neighbours}} } @will_destroy) ], \@will_destroy)) {
	    @{$b->{neighbours}} = difference2($b->{neighbours}, \@will_destroy);
	}
	@{$sticked_bubbles{$player}} = difference2($sticked_bubbles{$player}, \@will_destroy);
	@{$root_bubbles{$player}} = difference2($root_bubbles{$player}, \@will_destroy);

	$bubble->{'cx'} = $xpos;
	$bubble->{'cy'} = $ypos;
	calc_real_pos($bubble, $player);
	destroy_bubbles($player, @will_destroy, $bubble);

	#- find falling bubbles
	$_->{mark} = 0 foreach @{$sticked_bubbles{$player}};
	my @still_sticked;
	my @neighbours = @{$root_bubbles{$player}};
	my $distance_to_root;
	while (1) {
	    $_->{mark} = ++$distance_to_root foreach @neighbours;
	    push @still_sticked, @neighbours;
	    @neighbours = grep { $_->{mark} == 0 } map { @{$_->{neighbours}} } @neighbours;
	    last if !@neighbours;
	}
	@falling = difference2($sticked_bubbles{$player}, \@still_sticked);
	@{$sticked_bubbles{$player}} = difference2($sticked_bubbles{$player}, \@falling);

	#- chain-reaction on falling bubbles
	if ($chainreaction) {
	    my @falling_colors = map { $_->{img} } @falling;
	    #- optimize a bit by first calculating bubbles that are next to another bubble of the same color
	    my @grouped_bubbles = grep {
		my $b = $_;
		member($b->{img}, @falling_colors) && any { $b->{img} eq $_->{img} } @{$b->{neighbours}}
	    } @{$sticked_bubbles{$player}};
	    if (@grouped_bubbles) {
		#- all positions on which we can't chain-react
		my @occupied_positions = map { $_->{cy}*8 + $_->{cx} } @{$sticked_bubbles{$player}};
		push @occupied_positions, map { $_->{chaindestcy}*8 + $_->{chaindestcx} } @{$chains{$player}{falling_chained}};
		#- examine groups beginning at the root bubbles, for the case in which
		#- there is a group that will fall from an upper chain-reaction
		foreach my $pos (sort { $a->{mark} <=> $b->{mark} } @grouped_bubbles) {
		    #- now examine if there is a free position to chain-react in it
		    foreach my $npos (next_positions($pos, $player)) {
			#- we can't chain-react somewhere if it explodes a group already chained
			next if any { $pos->{cx} == $_->{cx} && $pos->{cy} == $_->{cy} }
			        map { @{$chains{$player}{chained_bubbles}{$_}}} keys %{$chains{$player}{chained_bubbles}};
			if (!member($npos->[1]*8 + $npos->[0], @occupied_positions)) {
			    #- find a suitable falling bubble for that free position
			    foreach my $falling (@falling) {
				next if member($falling, @{$chains{$player}{falling_chained}});
				if ($pos->{img} eq $falling->{img}) {
				    ($falling->{chaindestcx}, $falling->{chaindestcy}) = ($npos->[0], $npos->[1]);
				    ($falling->{chaindestx}, $falling->{chaindesty}) = calc_real_pos_given_arraypos($npos->[0], $npos->[1], $player);
				    push @{$chains{$player}{falling_chained}}, $falling;
				    push @occupied_positions, $npos->[1]*8 + $npos->[0];
				    
				    #- next lines will allow not to chain-react on the same group from two different positions,
				    #- and even to not chain-react on a group that will itself fall from a chain-reaction
				    @{$falling->{neighbours}} = grep { bubble_next_to($_->{cx}, $_->{cy}, $npos->[0], $npos->[1], $player) } @{$sticked_bubbles{$player}};
				    my @chained_bubbles = find_bubble_group($falling);
				    $_->{mark} = 0 foreach @{$sticked_bubbles{$player}};
				    my @still_sticked;
				    my @neighbours = difference2($root_bubbles{$player}, \@chained_bubbles);
				    while (1) {
					$_->{mark} = 1 foreach @neighbours;
					push @still_sticked, @neighbours;
					@neighbours = difference2([ grep { $_->{mark} == 0 } map { @{$_->{neighbours}} } @neighbours ],
								  \@chained_bubbles);
					last if !@neighbours;
				    }
				    @{$chains{$player}{chained_bubbles}{$falling}} = difference2($sticked_bubbles{$player}, \@still_sticked);
				    last;
				}
			    }
			}
		    }
		}
	    }
	}

	#- prepare falling bubbles
	if ($graphics_level > 1) {
	    my $max_cy_falling = fold_left { $::b->{cy} > $::a ? $::b->{cy} : $::a } 0, @falling;  #- I have a fold_left in my prog! :-)
	    my ($shift_on_same_line, $line) = (0, $max_cy_falling);
	    foreach (sort { $b->{cy}*8 + $b->{cx} <=> $a->{cy}*8 + $a->{cx} } @falling) {  #- sort bottom-to-up / right-to-left
		$line != $_->{cy} and $shift_on_same_line = 0;
		$line = $_->{cy};
		$_->{wait_fall} = ($max_cy_falling - $_->{cy})*5 + $shift_on_same_line;
		$shift_on_same_line++;
		$_->{speed} = 0;
	    }
	    push @{$falling_bubble{$player}}, @falling;
	}

	remove_images_from_background($player, @will_destroy, @falling);
	#- redraw neighbours because parts of neighbours have been erased by previous statement
	put_image_to_background($_->{img}, $_->{'x'}, $_->{'y'})
	  foreach grep { !member($_, @will_destroy) && !member($_, @falling) } fastuniq(map { @{$_->{neighbours}} } @will_destroy, @falling);
	$need_redraw = 1;
    }

    if ($count_for_root) {
	$pdata{$player}{newroot}++;
	if ($pdata{$player}{newroot} == $TIME_APPEARS_NEW_ROOT-1) {
	    $pdata{$player}{newroot_prelight} = 2;
	    $pdata{$player}{newroot_prelight_step} = 0;
	}
	if ($pdata{$player}{newroot} == $TIME_APPEARS_NEW_ROOT) {
	    $pdata{$player}{newroot_prelight} = 1;
	    $pdata{$player}{newroot_prelight_step} = 0;
	}
	if ($pdata{$player}{newroot} > $TIME_APPEARS_NEW_ROOT) {
	    $need_redraw = 1;
	    $pdata{$player}{newroot_prelight} = 0;
	    play_sound(is_1p_game() ? 'newroot_solo' : 'newroot');
	    $pdata{$player}{newroot} = 0;
	    $pdata{$player}{oddswap} = !$pdata{$player}{oddswap};
	    remove_images_from_background($player, @{$sticked_bubbles{$player}});
	    foreach (@{$sticked_bubbles{$player}}) {
		$_->{'cy'}++;
		calc_real_pos($_, $player);
	    }
	    foreach (@{$falling_bubble{$player}}) {
		exists $_->{chaindestx} or next;
		$_->{chaindestcy}++;
		$_->{chaindesty} += $ROW_SIZE;
	    }
	    put_allimages_to_background($player);
	    if (is_1p_game()) {
		$pdata{$player}{newrootlevel}++;
		print_compressor();
	    } else {
		@{$root_bubbles{$player}} = ();
		real_stick_bubble(create_bubble_given_img_num($pdata{$player}{nextcolors}[$_]), $_, 0, $player, 0) foreach (0..(7-$pdata{$player}{oddswap}));
                delete $pdata{$player}{nextcolors};
	    }
	}
    }

    if ($need_redraw) {
	my $malus_val = @will_destroy + @falling - 2;
	$malus_val > 0 and $malus_val += ($player eq 'p1' ? $playermalus : -$playermalus);
	$malus_val < 0 and $malus_val = 0;
	$background->blit($apprects{$player}, $app, $apprects{$player});
	malus_change($malus_val, $player);
    }

#    push @{$history{$player}}, { sticking => [ $xpos, $ypos, img2numb($bubble->{img}) ],
#				 oddswap => $pdata{$player}{oddswap},
#				 sticked => [ map { [ $_->{cx}, $_->{cy}, img2numb($_->{img}) ] } @{$sticked_bubbles{$player}} ] };
}

sub print_next_bubble($$;$) {
    my ($img, $player, $not_on_top_next) = @_;
    put_image_to_background($img, $next_bubble{$player}{'x'}, $next_bubble{$player}{'y'});
    $not_on_top_next or put_image_to_background($bubbles_anim{on_top_next},
                                                $POS{$player}{left_limit} + $POS{$player}{next_bubble}{x} + $POS{$player}{on_top_next_relpos}{x},
                                                $POS{$player}{next_bubble}{'y'} + $POS{$player}{on_top_next_relpos}{'y'});
}

sub generate_new_bubble($$) {
    my ($player, $num) = @_;
    $tobe_launched{$player} = $next_bubble{$player};
    $tobe_launched{$player}{'x'} = ($POS{$player}{left_limit}+$POS{$player}{right_limit})/2 - $BUBBLE_SIZE/2;
    $tobe_launched{$player}{'y'} = $POS{$player}{'initial_bubble_y'};
    $next_bubble{$player} = create_bubble_given_img_num($num);
    $next_bubble{$player}{'x'} = $POS{$player}{left_limit}+$POS{$player}{next_bubble}{x}; #- necessary to keep coordinates, for verify_if_end
    $next_bubble{$player}{'y'} = $POS{$player}{next_bubble}{'y'};
    print_next_bubble($next_bubble{$player}{img}, $player);
}


#- ----------- game stuff -------------------------------------------------

sub handle_graphics($) {
    my ($fun) = @_;

    iter_players {
	#- bubbles
	foreach ($launched_bubble{$::p}, if_($fun ne \&erase_image, $tobe_launched{$::p})) {
	    $_ and $fun->($_->{img}, $_->{'x'}, $_->{'y'});
	}
	if ($fun eq \&put_image && $pdata{$::p}{newroot_prelight}) {
	    if ($pdata{$::p}{newroot_prelight_step}++ > 30*$pdata{$::p}{newroot_prelight}) {
		$pdata{$::p}{newroot_prelight_step} = 0;
	    }
	    if ($pdata{$::p}{newroot_prelight_step} <= 8) {
		my $hurry_overwritten = 0;
		foreach my $b (@{$sticked_bubbles{$::p}}) {
		    next if ($graphics_level == 1 && $b->{'cy'} > 0);  #- in low graphics, only prelight first row
		    $b->{'cx'}+1 == $pdata{$::p}{newroot_prelight_step} and put_image($b->{img}, $b->{'x'}, $b->{'y'});
		    $b->{'cx'} == $pdata{$::p}{newroot_prelight_step} and put_image($bubbles_anim{white}, $b->{'x'}, $b->{'y'});
		    $b->{'cy'} > 6 and $hurry_overwritten = 1;
		}
		$hurry_overwritten && $pdata{$::p}{hurry_save_img} and print_hurry($::p, 1);  #- hurry was potentially overwritten
	    }
	}
	if ($sticking_bubble{$::p} && $graphics_level > 1) {
	    my $b = $sticking_bubble{$::p};
	    if ($fun eq \&erase_image) {
		put_image($b->{img}, $b->{'x'}, $b->{'y'});
	    } else {
		if ($pdata{$::p}{sticking_step} == @{$bubbles_anim{stick}}) {
		    $sticking_bubble{$::p} = undef;
		} else {
		    put_image(${$bubbles_anim{stick}}[$pdata{$::p}{sticking_step}], $b->{'x'}, $b->{'y'});
		    if ($pdata{$::p}{sticking_step_slowdown}) {
			$pdata{$::p}{sticking_step}++;
			$pdata{$::p}{sticking_step_slowdown} = 0;
		    } else {
			$pdata{$::p}{sticking_step_slowdown}++;
		    }
		}
	    }
	}

	#- shooter
	if ($graphics_level > 1) {
	    my $num = int($angle{$::p}*$CANON_ROTATIONS_NB/($PI/2) + 0.5)-$CANON_ROTATIONS_NB;
	    $fun->($canon{img}{$num},
                   $POS{$::p}{canon}{x} + $canon{$::p =~ /rp/ ? 'data_mini' : 'data'}{$num}->[0],
		   $POS{$::p}{canon}{'y'} + $canon{$::p =~ /rp/ ? 'data_mini' : 'data'}{$num}->[1]);
	} else {
	    $fun->($shooter,
		   $POS{$::p}{simpleshooter}{x} + $POS{$::p}{simpleshooter}{diameter}*cos($angle{$::p}),
		   $POS{$::p}{simpleshooter}{'y'} - $POS{$::p}{simpleshooter}{diameter}*sin($angle{$::p}));
	}
	#- penguins
	if ($graphics_level == 3) {
	    $fun->($pinguin{$::p}{$pdata{$::p}{ping_right}{state}}[$pdata{$::p}{ping_right}{img}], $POS{$::p}{left_limit}+$POS{$::p}{pinguin}{x}, $POS{$::p}{pinguin}{'y'});
	}

	#- moving bubbles --> I want them on top of the rest
	foreach (@{$malus_bubble{$::p}}, @{$falling_bubble{$::p}}, @{$exploding_bubble{$::p}}) {
	    $fun->($_->{img}, $_->{'x'}, $_->{'y'});
	}

    };

}

#- extract it from "handle_graphics" to optimize a bit animations
sub malus_change($$) {
    my ($numb, $player) = @_;
    return if $numb == 0 || is_1p_game();
    my $update_malus = sub($) {
	my ($fun, $p) = @_;
	my $malus = $pdata{$p}{malus};
	my $y_shift = 0;
	while ($malus > 0) {
	    my $print = sub($) {
		my ($type) = @_;
                my $type_real = translate_mini_image($type);
		$fun->($type, $POS{$p}{malus}{x} - $type_real->width/2, $POS{$p}{malus}{'y'} - $y_shift - $type_real->height);
		$y_shift += $type_real->height - 1;
	    };
	    if ($malus >= 7) {
		$print->($malus_gfx{tomate});
		$malus -= 7;
	    } else {
		$print->($malus_gfx{banane});
		$malus--;
	    }
	}
    };
    if ($numb > 0) {
        my @living = living_players();
        $numb = int($numb/(@living-1) + 0.99);
        iter_players_ {
            if ($::p_ ne $player && member($::p_, @living)) {
                $update_malus->(\&remove_image_from_background, $::p_);
                $pdata{$::p_}{malus} += $numb;
                $update_malus->(\&put_image_to_background, $::p_);
            }
        };
    } else {
        $update_malus->(\&remove_image_from_background, $player);
        $pdata{$player}{malus} += $numb;
        $update_malus->(\&put_image_to_background, $player);
    }
}

sub print_compressor() {
    my $x = $POS{compressor_xpos};
    my $y = $POS{p1}{top_limit} + $pdata{$PLAYERS[0]}{newrootlevel} * $ROW_SIZE;
    my ($comp_main, $comp_ext) = ($imgbin{compressor_main}, $imgbin{compressor_ext});

    my $drect = SDL::Rect->new(-width => $comp_main->width, -height => $y,
			       -x => $x - $comp_main->width/2, '-y' => 0);
    $background_orig->blit($drect, $background, $drect);
    $display_on_app_disabled or $background_orig->blit($drect, $app, $drect);
    push @update_rects, $drect;

    put_image_to_background($comp_main, $x - $comp_main->width/2, $y - $comp_main->height);

    $y -= $comp_main->height - 3;

    while ($y > 0) {
	put_image_to_background($comp_ext, $x - $comp_ext->width/2, $y - $comp_ext->height);
	$y -= $comp_ext->height;
    }
}

sub check_mp_connection() {
    if (!fb_net::isconnected()) {
        put_image($imgbin{void_panel}, $MENUPOS{xpos_panel}, $MENUPOS{ypos_panel});
        my $message = 'LOST CONNECTION TO SERVER!';
        my $xpos = 320 - SDL_TEXTWIDTH($message)/2;
        $app->print($xpos, $MENUPOS{ypos_panel} + 30, $message);
        $app->flip;
        play_sound('cancel');
        fb_c_stuff::fbdelay(3000);
        $event->pump while $event->poll != 0;
        grab_key(0);
        die 'quit';
    }
}

sub add_loserz_chat_msg($) {
    my ($message) = @_;
    play_sound('menu_selected');
    push @{$pdata{loserz_chat_messages}}, $message;
    @{$pdata{loserz_chat_messages}} > 7 and shift @{$pdata{loserz_chat_messages}};
    my $y = $MENUPOS{ypos_panel} + 60;
    foreach my $msg (@{$pdata{loserz_chat_messages}}) {
        erase_line($y, $background, $MENUPOS{xpos_panel} + 10, $imgbin{void_panel}->width - 20);
        $app->print($MENUPOS{xpos_panel} + 10, $y, $msg);
        $y += 22;
    }
    push @update_rects, $apprects{main};
}

sub handle_game_events() {
    $event->pump;
    if ($event->poll != 0) {
	if ($event->type == SDL_KEYDOWN) {
	    my $keypressed = $event->key_sym;

            if (is_mp_game() && $pdata{p1}{state} eq 'lost' && !@{$sticked_bubbles{p1}}) {
                $pdata{p1}{state} = 'chatting';
                put_image_to_background($imgbin{void_panel}, $MENUPOS{xpos_panel}, $MENUPOS{ypos_panel});
                $app->print($MENUPOS{xpos_panel} + 10, $MENUPOS{ypos_panel} + 15, "CHAT WITH OTHER LOSERZ");
                $app->print($MENUPOS{xpos_panel} + 10, $MENUPOS{ypos_panel} + 35, "TO PLAY NEXT GAME, DONT HIT ESC!");
                $pdata{p1}{typed_chat} = '';
                @{$pdata{loserz_chat_messages}} = ();
                push @update_rects, $apprects{main};
                
            } elsif (is_mp_game() && $pdata{p1}{state} eq 'chatting') {
                        
                if ($keypressed == SDLK_RETURN() || $keypressed == SDLK_KP_ENTER()) {
                    my $message = "($pdata{p1}{nick}) $pdata{$::p}{typed_chat}";
                    fb_net::gsend("talk:$message");
                    add_loserz_chat_msg($message);
                    $pdata{$::p}{typed_chat} = '';
                } else {
                    $pdata{$::p}{typed_chat} = update_typed_chat($pdata{$::p}{typed_chat}, $keypressed, 25);
                    my $y_typingchat = 325;
                    erase_line($y_typingchat, $background, $MENUPOS{xpos_panel} + 10, $imgbin{void_panel}->width - 20);
                    my $target_message = "($pdata{p1}{nick}) $pdata{$::p}{typed_chat}";
                    if (SDL_TEXTWIDTH($target_message) > $imgbin{void_panel}->width - 20) {
                        $pdata{$::p}{typed_chat} =~ s/.$//;
                    }
                    $app->print($MENUPOS{xpos_panel} + 10, $y_typingchat, "SAY: $pdata{$::p}{typed_chat}");
                    push @update_rects, $apprects{main};
                }

            } else {
                iter_local_players {
                    my $pkey = is_1p_game() ? 'p2' : $::p;
                    foreach (qw(left right fire center)) {
                        $keypressed == $KEYS->{$pkey}{$_} and $actions{$::p}{$_} = 1, last;
                    }
                };
                
                if ($keypressed == $KEYS->{misc}{fs}) {
                    $fullscreen = !$fullscreen;
                    $app->fullscreen;
                }
                
                if ($keypressed == SDLK_PAUSE && !is_mp_game()) {
                    play_sound('pause');
                    $mixer_enabled && $mixer and $mixer->pause_music;
                    my $back_saved = switch_image_on_background($imgbin{back_paused}, 0, 0, 1);
                  pause_label:
                    while (1) {
                        my ($index, $side) = (0, 1);
                        while ($index || $side == 1) {
                            put_image(${$imgbin{paused}}[$index], $POS_1P{pause_clip}{x}, $POS_1P{pause_clip}{'y'});
                            $app->flip;
                            foreach (1..80) {
                                $app->delay(20);
                                $event->pump;
                                if ($event->poll != 0 && $event->type == SDL_KEYDOWN) {
                                    last pause_label if $event->key_sym != $KEYS->{misc}{fs};
                                    $fullscreen = !$fullscreen;
                                    $app->fullscreen;
                                }
                            }
                            rand() < 0.2 and play_sound('snore');
                            $index += $side;
                            if ($index == @{$imgbin{paused}}) {
                                $side = -1;
                                $index -= 2;
                            }
                        }
                    }
                    switch_image_on_background($back_saved, 0, 0);
                    iter_local_players { $actions{$::p}{left} = 0; $actions{$::p}{right} = 0; };
                    $mixer_enabled && $mixer and $mixer->resume_music;
                    $event->pump while $event->poll != 0;
                    $app->flip;
                }
                
            }
        }

	if ($event->type == SDL_KEYUP) {
	    my $keypressed = $event->key_sym;

	    iter_local_players {
		my $pkey = is_1p_game() ? 'p2' : $::p;
		foreach (qw(left right fire center)) {
		    $keypressed == $KEYS->{$pkey}{$_} and $actions{$::p}{$_} = 0, last;
		}
	    }
	}

	if ($event->type == SDL_KEYDOWN && $event->key_sym == SDLK_ESCAPE) {
            if (is_mp_game()) {
                $pdata{p1}{left} = 1;
                lose('p1');
            }
	    die 'quit';
	}
        if ($event->type == SDL_QUIT) {
            exit 0;
        }
    }

    if (is_mp_game()) {
        my @messages = fb_net::grecv();

        check_mp_connection();

        #- in order to keep ordering of actions executed in update_game, we must tolerate only one action at a time
        my @keep_messages;
        my $check_action_possible = sub {
            my ($m, $player) = @_;
            if ($actions{$player}{mp_fire} || $actions{$player}{mp_stick} || any { $_->{mp_stick} } @{$malus_bubble{$player}}) {
                push @keep_messages, $m;
                return 0;
            } else {
                return 1;
            }
        };
        foreach my $m (@messages) {
            my $player = $pdata{id2p}{$m->{id}};
            my ($command, $params) = $m->{msg} =~ /(\w+):(.*)/;
            if ($command eq 'ping') {
                $pdata{$player}{ping} = $frame;
            } elsif ($command eq 'leave') {
                print "rcv leave from $player\n";
                iter_players { #- need iter_players to get the small graphics change for free
                    if ($::p eq $player) {
                        $pdata{$::p}{left} = 1;
                        lose($::p);
                    }
                };
            } elsif ($command eq 'fire') {
                if ($check_action_possible->($m, $player)) {
                    $actions{$player}{mp_fire} = 1;
                    ($angle{$player}, $pdata{$player}{nextcolor}) = $params =~ /(.+):(.+)/;
                }
            } elsif ($command eq 'angle') {
                $angle{$player} = $params;
            } elsif ($command eq 'stick') {
                if ($check_action_possible->($m, $player)) {
                    #- we can't rely on locally animated launched bubble, to ensure game
                    #- consistency we transmit stick positions
                    $actions{$player}{mp_stick} = 1;
                    ($pdata{$player}{stickcx}, $pdata{$player}{stickcy}, $pdata{$player}{stickcol}, my $newrootcols) = $params =~ /(.+):(.+):(.+):(.*)/;
                    @{$pdata{$player}{nextcolors}} = split / /, $newrootcols;
                }
            } elsif ($command eq 'malustick') {
                if ($check_action_possible->($m, $player)) {
                    my ($cx, $cy) = $params =~ /(.+):(.+)/;
                    foreach my $b (@{$malus_bubble{$player}}) {
                        if ($b->{'cx'} == $cx && $b->{'stick_y'} == $cy) {
                            $b->{mp_stick} = 1;
                        }
                    }
                }
            } elsif ($command eq 'malus') {
                my ($num, $cx, $cy, $sticky) = $params =~ /(.+):(.+):(.+):(.+)/;
                my $b = create_bubble_given_img_num($num);
                $b->{cx} = $cx;
                $b->{cy} = $cy;
                $b->{'stick_y'} = $sticky;
                iter_players { #- need iter_players to get the small graphics change for free
                    if ($::p eq $player) {
                        calc_real_pos($b, $::p);
                        push @{$malus_bubble{$player}}, $b;
                        malus_change(-1, $player);
                    }
                };
            } elsif ($command eq 'finished') {
                #- this is coming too soon. it needs to be collected in the algo to restart a game.
                push @keep_messages, $m;
            } elsif ($command eq 'talk') {
                if ($pdata{p1}{state} eq 'chatting') {
                    #- chat for loserz
                    add_loserz_chat_msg($params);
                }
            } else {
                print STDERR "Unrecognized command: $m->{msg}\n";
            }
        }
        fb_net::gdelay_messages(@keep_messages);
        $frame % 25 == 0 and fb_net::gsend('ping:');
        iter_distant_players {
            if ($pdata{$::p}{state} eq 'ingame' && $pdata{$::p}{ping} + 200 < $frame) {
                print STDERR "Dropping player $::p, doesn't ping us anymore for ages.\n";
                $pdata{$::p}{left} = 1;
                lose($::p);
            }
        };
    }
}

sub print_scores($) {
    my ($surface) = @_;  
    iter_players_ {  #- sometimes called from within a iter_players so...
        my $xpos = $POS{$::p_}{scores}{x}-SDL_TEXTWIDTH($pdata{$::p_}{score})/2;
        my $drect = SDL::Rect->new(-width => 30, -height => 30, -x => $xpos - 5, '-y' => $POS{$::p_}{scores}{'y'});
        $background_orig->blit($drect, $surface, $drect);
        push @update_rects, $drect;
	$surface->print($xpos, $POS{$::p_}{scores}{'y'}, $pdata{$::p_}{score});
	!is_local_player($::p_) and $surface->print($POS{$::p_}{nick}{x}-SDL_TEXTWIDTH($pdata{$::p_}{nick})/2, $POS{$::p_}{nick}{'y'}, $pdata{$::p_}{nick});
    };
}

sub cleanup_player_bubbles {
    my ($player) = @_;
    @{$malus_bubble{$player}} = ();
    #- reverse sort for freezing effect and win effect
    @{$sticked_bubbles{$player}} = sort { $b->{'cx'}+$b->{'cy'}*10 <=> $a->{'cx'}+$a->{'cy'}*10 } @{$sticked_bubbles{$player}};
    remove_hurry($player);
    @{$falling_bubble{$player}} = grep { !exists $_->{chaindestx} } @{$falling_bubble{$player}};
    $sticking_bubble{$player} = undef;
    $launched_bubble{$player} and destroy_bubbles($player, $launched_bubble{$player});
    $launched_bubble{$player} = undef;
    $pdata{$player}{newroot_prelight} = 0;
}

sub win {
    my ($player) = @_;
    every { !$pdata{$_}{left} } @PLAYERS and $pdata{$player}{score}++;
    $pdata{$player}{ping_right}{state} = 'win';
    $pdata{$player}{ping_right}{img} = 0;
    print_scores($background);
    print_scores($app);
    cleanup_player_bubbles($player);
}

sub lose {
    my ($player) = @_;
    print "lose($player)\n".backtrace();
    $pdata{$player}{ping_right}{state} = 'lose';
    $pdata{$player}{ping_right}{img} = 0;
    foreach ($launched_bubble{$player}, $tobe_launched{$player}, @{$malus_bubble{$player}}) {
        $_ or next;
        $_->{img} = $bubbles_anim{lose};
        $_->{'x'}--;
        $_->{'y'}--;
    }
    print_next_bubble($bubbles_anim{lose}, $player, 1);
    cleanup_player_bubbles($player);
    
    if (is_mp_game()) {
        $pdata{$player}{state} = 'lost';
        my @living = living_players();
        if (@living == 1) {
            print "living == 1\n";
            if (any { $pdata{$_}{left} } @PLAYERS) {
                $pdata{$_}{left} and print "$_ left!\n" foreach @PLAYERS;
                #- if some players have left, directly go to won state
                win($living[0]);
                $pdata{state} = "won $living[0]";
            } else {
                #- tentatively suppose we've found the winner, but we need to confirm it by network
                #- first, in rare case of two last players dying at the same time
                my $winnernick = $pdata{$living[0]}{nick};
                fb_net::gsend("finished:$winnernick");
                $pdata{state} = "finished $living[0]:$winnernick 0";
            }
        }
        if ($pdata{$player}{left}) {
            put_image_to_background($imgbin{left},
                                    $POS{$player}{left_limit},
                                    $POS{$player}{top_limit}); #- TOFIX
            @{$sticked_bubbles{$player}} = ();
            play_sound('cancel');
        } else {
            play_sound('lose');
        }

    } else {
        play_sound('lose');
        $pdata{state} = "lost $player";
        is_2p_game() and win($player eq 'p1' ? 'p2' : 'p1');
    }
  ret:
}

sub verify_if_end {
    iter_players {
	if ($pdata{state} eq 'game' && any { $_->{cy} > 11 } @{$sticked_bubbles{$::p}}) {
            lose($::p);
	}
    };

    if (is_1p_game() && @{$sticked_bubbles{$PLAYERS[0]}} == 0) {
	put_image_to_background($imgbin{win_panel_1player}, $POS{centerpanel}{x}, $POS{centerpanel}{'y'});
	$pdata{state} = "won $PLAYERS[0]";
	$pdata{$PLAYERS[0]}{ping_right}{state} = 'win';
	$pdata{$PLAYERS[0]}{ping_right}{img} = 0;
	$levels{current} and $levels{current}++;
	if ($levels{current} && !$levels{$levels{current}}) {
	    $levels{current} = 'WON';
	    @{$falling_bubble{$PLAYERS[0]}} = @{$exploding_bubble{$PLAYERS[0]}} = ();
	    die 'quit';
	}
    }
}

sub print_hurry($;$) {
    my ($player, $dont_save_background) = @_;
    my $t = switch_image_on_background($imgbin{hurry}{$player}, $POS{$player}{left_limit} + $POS{$player}{hurry}{x}, $POS{$player}{hurry}{'y'}, 1);
    $dont_save_background or $pdata{$player}{hurry_save_img} = $t;
}
sub remove_hurry($) {
    my ($player) = @_;
    $pdata{$player}{hurry_save_img} and
      switch_image_on_background($pdata{$player}{hurry_save_img}, $POS{$player}{left_limit} + $POS{$player}{hurry}{x}, $POS{$player}{hurry}{'y'});
    $pdata{$player}{hurry_save_img} = undef;
}

sub update_lost {
    my ($player) = @_;

    return if odd($frame);

    my $still_sticked;

    iter_players { #- need iter_players to get the small graphics change for free if we're in multiplayer
        if ($::p eq $player) {
            if (@{$sticked_bubbles{$player}}) {
                my $b = shift @{$sticked_bubbles{$player}};
                put_image_to_background($bubbles_anim{lose}, --$b->{'x'}, --$b->{'y'});
                
                if (@{$sticked_bubbles{$player}} == 0) {
                    if ($graphics_level == 1 && $pdata{state} =~ /^lost (.*)/ && !is_1p_game()) {
                        put_image($imgbin{win}{$player eq 'p1' ? 'p2' : 'p1'}, $POS{centerpanel}{x}, $POS{centerpanel}{'y'});
                    }
                    if (is_1p_game()) {
                        put_image($imgbin{lose}, $POS{centerpanel}{'x'}, $POS{centerpanel}{'y'});
                        play_sound('noh');
                    }
                }
                
                if (!@{$sticked_bubbles{$player}}) {
                    $event->pump while $event->poll != 0;
                }
            } else {
                if (!is_mp_game()) {
                    $event->pump;
                    die 'new_game' if $event->poll != 0 && $event->type == SDL_KEYDOWN;
                }
            }
        }
        $still_sticked += @{$sticked_bubbles{$::p}};
    };

    if ($pdata{state} eq 'won ' && $still_sticked == 1) {
        put_image($imgbin{void_panel}, $MENUPOS{xpos_panel}, $MENUPOS{ypos_panel});
        my $message = "DRAW GAME!";
        my $xpos = 320 - SDL_TEXTWIDTH($message)/2;
        $app->print($xpos, $MENUPOS{ypos_panel} + 30, $message);
        $app->flip;
    }
}

sub update_won {
    my ($player) = @_;

    return if odd($frame);

    iter_players { #- need iter_players to get the small graphics change for free if we're in multiplayer
        if ($::p eq $player) {
            if (@{$sticked_bubbles{$::p}} && $graphics_level > 1) {
                my $b = shift @{$sticked_bubbles{$::p}};
                destroy_bubbles($::p, $b);
                remove_image_from_background($b->{img}, $b->{'x'}, $b->{'y'});
                #- be sure to redraw at least upper line
                foreach (@{$b->{neighbours}}) {
                    next if !member($_, @{$sticked_bubbles{$::p}});
                    put_image_to_background($_->{img}, $_->{'x'}, $_->{'y'});
                }
            }
        }
    };
}

sub decode_postgame_message($) {
    my ($msg) = @_;
    my $player = $pdata{id2p}{$msg->{id}};
    $player ||= 'UNKNOWN';
    if ($msg->{msg} =~ /^\Qfinished:\E(.*)/) {
        $pdata{$player}{still_game_messages} = 0;
        return "$player finished $1";
    } elsif ($pdata{$player}{still_game_messages}) {
        return "$player gamemsg";
    } else {
        if ($msg->{msg} =~ /^\Qnewgame:\E/) {
            $pdata{$player}{ready4newgame} = 1;
            return "$player newgame";
        } else {
            return "$player other";
        }
    }
}


#- ----------- mainloop helper --------------------------------------------

sub update_game() {

    if ($pdata{state} eq 'game') {
	handle_game_events();
	iter_players {
            if ($pdata{$::p}{state} eq 'lost') {
                update_lost($::p);

            } elsif ($pdata{$::p}{state} eq 'ingame') {
                $actions{$::p}{left} and $angle{$::p} += $LAUNCHER_SPEED;
                $actions{$::p}{right} and $angle{$::p} -= $LAUNCHER_SPEED;
                if ($actions{$::p}{center}) {
                    if ($angle{$::p} >= $PI/2 - $LAUNCHER_SPEED
                        && $angle{$::p} <= $PI/2 + $LAUNCHER_SPEED) {
                        $angle{$::p} = $PI/2;
                    } else {
                        $angle{$::p} += ($angle{$::p} < $PI/2) ? $LAUNCHER_SPEED : -$LAUNCHER_SPEED;
                    }
                }
                ($angle{$::p} < 0.1) and $angle{$::p} = 0.1;
                ($angle{$::p} > $PI-0.1) and $angle{$::p} = $PI-0.1;
                if (is_mp_game() && ($actions{$::p}{left} || $actions{$::p}{right} || $actions{$::p}{center})) {
                    fb_net::gsend("angle:$angle{$::p}");
                }
                $pdata{$::p}{hurry}++;
                if ($pdata{$::p}{hurry} > $TIME_HURRY_WARN) {
                    my $oddness = odd(int(($pdata{$::p}{hurry}-$TIME_HURRY_WARN)/(500/$TARGET_ANIM_SPEED))+1);
                    if ($pdata{$::p}{hurry_oddness} xor $oddness) {
                        if ($oddness) {
                            play_sound('hurry');
                            print_hurry($::p);
                        } else {
                            remove_hurry($::p)
                        }
                    }
                    $pdata{$::p}{hurry_oddness} = $oddness;
                }

                if ($actions{$::p}{mp_fire}
                    || (is_local_player($::p)
                        && ($actions{$::p}{fire} || $pdata{$::p}{hurry} == $TIME_HURRY_MAX)
                        && !$launched_bubble{$::p}
                        && !(any { exists $_->{chaindestx} } @{$falling_bubble{$::p}})
                        && !@{$malus_bubble{$::p}})) {
                    play_sound('launch');
                    $launched_bubble{$::p} = $tobe_launched{$::p};
                    $launched_bubble{$::p}->{direction} = $angle{$::p};
                    $tobe_launched{$::p} = undef;
                    $actions{$::p}{fire} = 0;
                    $actions{$::p}{hadfire} = 1;
                    $pdata{$::p}{hurry} = 0;
                    remove_hurry($::p);
                    if (is_mp_game()) {
                        if (is_local_player($::p)) {
                            $pdata{$::p}{nextcolor} = int(rand(@bubbles_images));
                            fb_net::gsend("fire:$angle{$::p}:$pdata{$::p}{nextcolor}");
                        }
                        $actions{$::p}{mp_fire} = 0;
                    } else {
                        do {
                            $pdata{$::p}{nextcolor} = int(rand(@bubbles_images));
                        } while (!validate_nextcolor($pdata{$::p}{nextcolor}, $::p));
                    }
                }

                if ($launched_bubble{$::p}) {
                    $launched_bubble{$::p}->{'x_old'} = $launched_bubble{$::p}->{'x'}; # save coordinates for potential collision
                    $launched_bubble{$::p}->{'y_old'} = $launched_bubble{$::p}->{'y'};
                    $launched_bubble{$::p}->{'x'} += $BUBBLE_SPEED * cos($launched_bubble{$::p}->{direction});
                    $launched_bubble{$::p}->{'y'} -= $BUBBLE_SPEED * sin($launched_bubble{$::p}->{direction});
                    if ($launched_bubble{$::p}->{x} < $POS{$::p}{left_limit}) {
                        play_sound('rebound');
                        $launched_bubble{$::p}->{x} = 2 * $POS{$::p}{left_limit} - $launched_bubble{$::p}->{x};
                        $launched_bubble{$::p}->{direction} -= 2*($launched_bubble{$::p}->{direction}-$PI/2);
                    }
                    if ($launched_bubble{$::p}->{x} > $POS{$::p}{right_limit} - $BUBBLE_SIZE) {
                        play_sound('rebound');
                        $launched_bubble{$::p}->{x} = 2 * ($POS{$::p}{right_limit} - $BUBBLE_SIZE) - $launched_bubble{$::p}->{x};
                        $launched_bubble{$::p}->{direction} += 2*($PI/2-$launched_bubble{$::p}->{direction});
                    }
                    if (!exists $pdata{$::p}{nextcolors}) {
                        @{$pdata{$::p}{nextcolors}} = map { int(rand(@bubbles_images)) } 0..7;
                    }
                    if ($actions{$::p}{mp_stick}) {
                        $actions{$::p}{mp_stick} = 0;
                        if (get_bubble_num($launched_bubble{$::p}) ne $pdata{$::p}{stickcol}) {
                            print ">>>>>>>>>>>>>>>>> color inconsistency, I bet I will backtrace soon!\n";
                        }
                        stick_bubble($launched_bubble{$::p}, $pdata{$::p}{stickcx}, $pdata{$::p}{stickcy}, $::p, 1);
                        $launched_bubble{$::p} = undef;
                    }
                    if (is_local_player($::p)) {
                        if ($launched_bubble{$::p}->{'y'} <= $POS{$::p}{top_limit} + $pdata{$::p}{newrootlevel} * $ROW_SIZE) {
                            my ($cx, $cy) = get_array_closest_pos($launched_bubble{$::p}->{x}, $launched_bubble{$::p}->{'y'}, $::p);
                            my $col = get_bubble_num($launched_bubble{$::p});
                            is_mp_game() and fb_net::gsend("stick:$cx:$cy:$col:@{$pdata{$::p}{nextcolors}}");
                            stick_bubble($launched_bubble{$::p}, $cx, $cy, $::p, 1);
                            $launched_bubble{$::p} = undef;
                        } else {
                            foreach (@{$sticked_bubbles{$::p}}) {
                                if (is_collision($launched_bubble{$::p}, $_->{'x'}, $_->{'y'})) {
                                    my ($cx, $cy) = get_array_closest_pos(($launched_bubble{$::p}->{'x_old'}+$launched_bubble{$::p}->{'x'})/2,
                                                                          ($launched_bubble{$::p}->{'y_old'}+$launched_bubble{$::p}->{'y'})/2,
                                                                          $::p);
                                    my $col = get_bubble_num($launched_bubble{$::p});
                                    is_mp_game() and fb_net::gsend("stick:$cx:$cy:$col:@{$pdata{$::p}{nextcolors}}");
                                    stick_bubble($launched_bubble{$::p}, $cx, $cy, $::p, 1);
                                    $launched_bubble{$::p} = undef;
                                    
                                    #- malus generation
                                    if (!any { $_->{chaindestx} } @{$falling_bubble{$::p}}) {
                                        $pdata{$::p}{malus} > 0 and play_sound('malus');
                                        while ($pdata{$::p}{malus} > 0 && @{$malus_bubble{$::p}} < 7) {
                                            my $num = int(rand(@bubbles_images));
                                            my $b = create_bubble_given_img_num($num);
                                            $b->{num} = $num;
                                            do {
                                                $b->{'cx'} = int(rand(7));
                                            } while (member($b->{'cx'}, map { $_->{'cx'} } @{$malus_bubble{$::p}}));
                                            $b->{'cy'} = 12;
                                            $b->{'stick_y'} = 0;
                                            foreach (@{$sticked_bubbles{$::p}}) {
                                                if ($_->{'cy'} > $b->{'stick_y'}) {
                                                    if ($_->{'cx'} == $b->{'cx'}
                                                        || odd($_->{'cy'}+$pdata{$::p}{oddswap}) && ($_->{'cx'}+1) == $b->{'cx'}) {
                                                        $b->{'stick_y'} = $_->{'cy'};
                                                    }
                                                }
                                            }
                                            $b->{'stick_y'}++;
                                            calc_real_pos($b, $::p);
                                            push @{$malus_bubble{$::p}}, $b;
                                            malus_change(-1, $::p);
                                        }
                                        #- sort them and shift them
                                        @{$malus_bubble{$::p}} = sort { $a->{'cx'} <=> $b->{'cx'} } @{$malus_bubble{$::p}};
                                        my $shifting = 0;
                                        $_->{'y'} += ($shifting+=7)+int(rand(20)) foreach @{$malus_bubble{$::p}};
                                        if (is_mp_game()) {
                                            fb_net::gsend("malus:$_->{num}:$_->{cx}:$_->{cy}:$_->{stick_y}") foreach @{$malus_bubble{$::p}};
                                        }
                                    }
                                    
                                    last;
                                }
                            }
                        }
                    }
                }

                !$tobe_launched{$::p} and generate_new_bubble($::p, $pdata{$::p}{nextcolor});

                if (!$actions{$::p}{left} && !$actions{$::p}{right} && !$actions{$::p}{hadfire}) {
                    $pdata{$::p}{sleeping}++;
                } else {
                    $pdata{$::p}{sleeping} = 0;
                    $pdata{$::p}{ping_right}{movelatency} = -20;
                }
                if ($pdata{$::p}{sleeping} > $TIMEOUT_PINGUIN_SLEEP) {
                    $pdata{$::p}{ping_right}{state} = 'sleep';
                } elsif ($pdata{$::p}{ping_right}{state} eq 'sleep') {
                    $pdata{$::p}{ping_right}{state} = 'normal';
                }
                if ($pdata{$::p}{ping_right}{state} eq 'right' && !($actions{$::p}{right})
                    || $pdata{$::p}{ping_right}{state} eq 'left' && !($actions{$::p}{left})
                    || $pdata{$::p}{ping_right}{state} eq 'action' && ($pdata{$::p}{ping_right}{actionlatency}++ > 5)) {
                    $pdata{$::p}{ping_right}{state} = 'normal';
                }
                $actions{$::p}{right} and $pdata{$::p}{ping_right}{state} = 'right';
                $actions{$::p}{left} and $pdata{$::p}{ping_right}{state} = 'left';
                if ($actions{$::p}{hadfire}) {
                    $pdata{$::p}{ping_right}{state} = 'action';
                    $actions{$::p}{hadfire} = 0;
                    $pdata{$::p}{ping_right}{actionlatency} = 0;
                }
                if ($pdata{$::p}{ping_right}{state} eq 'normal' && ($pdata{$::p}{ping_right}{movelatency}++ > 10)) {
                    $pdata{$::p}{ping_right}{movelatency} = 0;
                    rand() < 0.4 and $pdata{$::p}{ping_right}{img} = int(rand(@{$pinguin{$::p}{normal}}));
                }

                if ($pdata{$::p}{ping_right}{img} >= @{$pinguin{$::p}{$pdata{$::p}{ping_right}{state}}}) {
                    $pdata{$::p}{ping_right}{img} = 0;
                }
            }
        };

	verify_if_end();

    } elsif ($pdata{state} =~ /^lost (.*)/) {
        #- 1p and 2p game only state

        my $loser = $1;
        update_lost($loser);
        is_2p_game() and update_won($loser eq 'p1' ? 'p2' : 'p1');
        
    } elsif ($pdata{state} =~ /^finished (\S+):(\S+) (\S+)/) {
        print "$pdata{state}\n";
        #- mp game only state when we're trying to figure out if this is not a draw game

        my $supposed_winner_player = $1;
        my $supposed_winner_nick = $2;
        my $timeout_counter = $3;

        if (my $msg = fb_net::grecv_get1msg_ifdata()) {
            my $result = decode_postgame_message($msg);
            print "msg: $result\n";
            if ($result =~ /^(\S+) finished (\S+)/) {
                print "\tfinish msg\n";
                my $remote_winner_nick = $2;
                if ($remote_winner_nick ne $supposed_winner_nick) {
                    print "\tdisagree, draw\n";
                    #- players don't agree with who won the game, this is a draw game
                    $pdata{state} = "won ";
                    lose($supposed_winner_player);
                } else {
                    print "\tagree..\n";
                    if (every { $pdata{$_}{still_game_messages} == 0 } @PLAYERS) {
                        print "\tok, finish with $supposed_winner_player\n";
                        win($supposed_winner_player);
                        $pdata{state} = "won $supposed_winner_player";
                    } else {
                        print "\twaiting for: ";
                        $pdata{$_}{still_game_messages} and print "$_ " foreach @PLAYERS;
                        print "\n";
                    }
                }
            } elsif ($result =~ /^(\S+) other/) {
                print "finished state - $1 sends post-finish non-newgame $msg->{msg} - passing hand to won\n";
                win($supposed_winner_player);
                $pdata{state} = "won $supposed_winner_player";
            } elsif ($result !~ /^(\S+) gamemsg/) {
                print "finished state, delaying $msg->{msg}\n";
                fb_net::gdelay_messages($msg);
            }
            print "\tstate: $pdata{state}\n";
        } else {
            check_mp_connection();
            #- timeout for receiving the winners. it could happen when a client is badly killed.
            $timeout_counter++;
            if ($timeout_counter > $fb_net::timeout * (1000/$TARGET_ANIM_SPEED) ) {
                win($supposed_winner_player);
                $pdata{state} = "won $supposed_winner_player";
            } else {
                $pdata{state} = "finished $supposed_winner_player:$supposed_winner_nick $timeout_counter";
            }
        }

    } elsif ($pdata{state} =~ /^won (.*)/) {
        #- mp and 1p game only state

        my $winner = $1;
        if (is_mp_game()) {
            $winner and update_won($winner);
            iter_players {
                if ($::p ne $winner) {
                    update_lost($::p);
                }
            };
            check_mp_connection();
        }
	if (!$winner || @{$exploding_bubble{$winner}} == 0) {
            my $still_needwait = 0;
            #- still wait if some bubbles are not yet "frozen"
            iter_players {
                $still_needwait += @{$sticked_bubbles{$::p}};
            };
            if (!$still_needwait) {
                $event->pump;
                if ($event->poll != 0 && $event->type == SDL_KEYDOWN) {
                    if ($event->key_sym == SDLK_ESCAPE()) {
                        die 'quit';
                    }
                    if (is_mp_game()) {
                        iter_players {
                            $pdata{$::p}{left} and die 'quit';
                        };
                        fb_net::gsend("newgame:");
                        my $redraw_waiting = sub {
                            put_image($imgbin{void_panel}, $MENUPOS{xpos_panel}, $MENUPOS{ypos_panel});
                            $app->print($MENUPOS{xpos_panel} + 10, $MENUPOS{ypos_panel} + 15, "WAITING FOR OTHER PLAYERS:");
                            my $y = $MENUPOS{ypos_panel} + 50;
                            iter_distant_players {
                                my $message = $pdata{$::p}{ready4newgame} ? "$pdata{$::p}{nick} IS READY!"
                                                                          : "WAITING FOR $pdata{$::p}{nick}...";
                                $app->print($MENUPOS{xpos_panel} + 10, $y, $message);
                                put_image($imgbin{'mp_'.($pdata{$::p}{ready4newgame} ? 'ready' : 'waiting').'_newgame'},
                                          $MENUPOS{xpos_panel} + 10 + SDL_TEXTWIDTH($message) + 5, $y);
                                $y += 25;
                            };
                            $app->flip;
                        };
                        $redraw_waiting->();
                        my $already_waited;
                        while (1) {
                            $event->pump;
                            if ($event->poll != 0) {
                                if ($event->type == SDL_KEYDOWN) {
                                    if ($event->key_sym == SDLK_ESCAPE()) {
                                        die 'quit';
                                    }
                                }
                            }
                            if (my $msg = fb_net::grecv_get1msg_ifdata()) {
                                my $result = decode_postgame_message($msg);
                                if ($result =~ /^(\S+) newgame/) {
                                    print "$pdata{$pdata{id2p}{$msg->{id}}}{nick} newgame\n";
                                    $already_waited and play_sound('newroot');
                                    $redraw_waiting->();
                                } elsif ($result =~ /^(\S+) other/) {
                                    print "quitting this game: $1 sends post-finish non-newgame $msg->{msg}\n";
                                    die 'quit';
                                }
                            }
                            #- need to do it here because we might have received two "newgame"
                            #- in a 3-players game, but one of them might have quitted while
                            #- this player was still not sending his newgame message
                            iter_distant_players {
                                $pdata{$::p}{ready4newgame} == 0 and goto still_waiting;
                            };
                            die 'new_game';
                          still_waiting:

                            fb_c_stuff::fbdelay(50);
                            check_mp_connection();
                            $already_waited = 1;
                        }
                    } else {
                        die 'new_game';
                    }
                }
            }
        }

    } else {
	die "oops unhandled game state ($pdata{state})\n";
    }


    #- things that need to be updated in all states of the game
    iter_players {
	my $malus_end = [];
	foreach my $b (@{$malus_bubble{$::p}}) {
	    $b->{'y'} -= $MALUS_BUBBLE_SPEED;
	    if ($b->{mp_stick}
                || is_local_player($::p) && get_array_yclosest($b->{'y'}, $::p) <= $b->{'stick_y'}) {
		real_stick_bubble($b, $b->{'cx'}, $b->{'stick_y'}, $::p, 0);
		push @$malus_end, $b;
                if (is_mp_game() && is_local_player($::p)) {
                    fb_net::gsend("malustick:$b->{cx}:$b->{stick_y}");
                }
	    }
	}
	@$malus_end and @{$malus_bubble{$::p}} = difference2($malus_bubble{$::p}, $malus_end);

	my $falling_end = [];
	foreach my $b (@{$falling_bubble{$::p}}) {
	    if ($b->{wait_fall}) {
		$b->{wait_fall}--;
	    } else {
		if (exists $b->{chaindestx} && ($b->{'y'} > 375 || $b->{chaingoingup})) {
		    my $acceleration = $FREE_FALL_CONSTANT*3;
		    if (!$b->{chaingoingup}) {
			my $time_to_zero = $b->{speed}/$acceleration;
			my $distance_to_zero = $b->{speed} * ($b->{speed}/$acceleration + 1) / 2;
			my $time_to_destination = (-1 + sqrt(1 + 8/$acceleration*($b->{'y'}-$b->{chaindesty}+$distance_to_zero))) / 2;
			$b->{speedx} = ($b->{chaindestx} - $b->{x}) / ($time_to_zero + $time_to_destination);
			$b->{chaingoingup} = 1;
		    }
		    $b->{speed} -= $acceleration;
		    $b->{x} += $b->{speedx};
		    if (abs($b->{x} - $b->{chaindestx}) < abs($b->{speedx})) {
			$b->{'x'} = $b->{chaindestx};
			$b->{speedx} = 0;
		    }
		    $b->{'y'} += $b->{speed};
		    $b->{'y'} < $b->{chaindesty} and push @$falling_end, $b;
		} else {
		    $b->{'y'} += $b->{speed};
		    $b->{speed} += $FREE_FALL_CONSTANT;
		}
	    }
	    $b->{'y'} > 470 && !exists $b->{chaindestx} and push @$falling_end, $b;
	}
	@$falling_end and @{$falling_bubble{$::p}} = difference2($falling_bubble{$::p}, $falling_end);
	foreach (@$falling_end) {
	    exists $_->{chaindestx} or next;
	    @{$chains{$::p}{falling_chained}} = difference2($chains{$::p}{falling_chained}, [ $_ ]);
	    delete $chains{$::p}{chained_bubbles}{$_};
	    stick_bubble($_, $_->{chaindestcx}, $_->{chaindestcy}, $::p, 0);
	}

	my $exploding_end = [];
	foreach my $b (@{$exploding_bubble{$::p}}) {
	    $b->{'x'} += $b->{speedx};
	    $b->{'y'} += $b->{speedy};
	    $b->{speedy} += $FREE_FALL_CONSTANT;
	    push @$exploding_end, $b if $b->{'y'} > 470;
	}
	if (@$exploding_end) {
	    @{$exploding_bubble{$::p}} = difference2($exploding_bubble{$::p}, $exploding_end);
	    if ($pdata{state} =~ /^lost (.*)/ && $::p ne $1 && !is_1p_game()
		&& !@{$exploding_bubble{$::p}} && !@{$sticked_bubbles{$::p}}) {
		put_image($imgbin{win}{$::p}, $POS{centerpanel}{'x'}, $POS{centerpanel}{'y'});
	    }
	}

	if (member($pdata{$::p}{ping_right}{state}, qw(win lose)) && ($pdata{$::p}{ping_right}{movelatency}++ > 5)) {
	    my $state = $pdata{$::p}{ping_right}{state};
	    $pdata{$::p}{ping_right}{movelatency} = 0;
	    $pdata{$::p}{ping_right}{img}++;
	    $pdata{$::p}{ping_right}{img} == @{$pinguin{$::p}{$state}}
	      and $pdata{$::p}{ping_right}{img} = $pinguin{$::p}{"$state".'_roll_back_index'};
	}

    };

    #- advance playlist when the current song finished
    $mixer_enabled && $mixer && @playlist && !$mixer->playing_music and play_music('dummy', 0);
}

#- ----------- init stuff -------------------------------------------------

sub restart_app() {
    $app = SDL::App->new(-icon => "$FPATH/gfx/pinguins/window_icon_penguin.png", -flags => $sdl_flags | ($fullscreen ? SDL_FULLSCREEN : 0), -title => 'Frozen-Bubble', -width => 640, -height => 480);
}

sub print_step($) {
    my ($txt) = @_;
    print $txt;
    my $step if 0; $step ||= 0;
    put_image($imgbin{loading_step}, 100 + $step*12, 10);
    $app->flip;
    $step++;
}

sub load_levelset {
    my ($levelset_name) = @_;

    -e $levelset_name or die "No such levelset ($levelset_name).\n";

    $loaded_levelset = $levelset_name;
    my $row_numb = 0;
    my $curr_level = $levels{current};

    %levels = ();
    $levels{current} = $curr_level;
    $lev_number = 1;

    foreach my $line (cat_($levelset_name)) {
	if ($line !~ /\S/) {
	    if ($row_numb) {
		$lev_number++;
		$row_numb = 0;
	    }
	} else {
	    my $col_numb = 0;
	    foreach (split ' ', $line) {
		/-/ or push @{$levels{$lev_number}}, { cx => $col_numb, cy => $row_numb, img_num => $_ };
		$col_numb++;
	    }
	    $row_numb++;
	}
    }
}

sub init_game() {
    -r "$FPATH/$_" or die "[*ERROR*] the datafiles seem to be missing! (could not read `$FPATH/$_')\n".
                          "          The datafiles need to go to `$FPATH'.\n"
			    foreach qw(gfx snd data);

    print '[SDL Init] ';
    restart_app();
    $frame = 0;
    $font = SDL::Font->new("$FPATH/gfx/font.png");
    $apprects{main} = SDL::Rect->new(-width => $app->width, -height => $app->height);
    $event = SDL::Event->new;
    $event->set_unicode(1);
    SDL::Cursor::show(0);
    $total_time = $app->ticks;
    $imgbin{loading} = add_image('loading.png');
    put_image($imgbin{loading}, 10, 10);
    $app->print(30, 60, uc("tip!  use '-h' on command-line to get more options"));
    $app->flip;
    $imgbin{loading_step} = add_image('loading_step.png');
 
    print_step('[Graphics');
    $imgbin{back_2p} = SDL::Surface->new(-name => "$FPATH/gfx/backgrnd.png");
    $imgbin{back_1p} = SDL::Surface->new(-name => "$FPATH/gfx/back_one_player.png");
    $imgbin{back_mp} = SDL::Surface->new(-name => "$FPATH/gfx/back_multiplayer.png");
    $background = SDL::Surface->new(-width => $app->width, -height => $app->height, -depth => 32, -Amask => '0 but true');
    $background_orig = SDL::Surface->new(-width => $app->width, -height => $app->height, -depth => 32, -Amask => '0 but true');
    $imgbin{backstartfull} = SDL::Surface->new(-name => "$FPATH/gfx/menu/back_start.png");

    print_step('.'); 
    foreach my $ball (1..8) {
        my $img = add_bubble_image('balls/bubble-'.($colourblind && 'colourblind-')."$ball.gif");
        $img_mini{$img} = add_image('balls/bubble-'.($colourblind && 'colourblind-')."${ball}-mini.png");
    }
    $bubbles_anim{white} = add_image("balls/bubble_prelight.png");
    $img_mini{$bubbles_anim{white}} = add_image("balls/bubble_prelight-mini.png");
    $bubbles_anim{lose} = add_image("balls/bubble_lose.png");
    $img_mini{$bubbles_anim{lose}} = add_image("balls/bubble_lose-mini.png");
    $bubbles_anim{on_top_next} = add_image("on_top_next.png");
    $img_mini{$bubbles_anim{on_top_next}} = add_image("on_top_next-mini.png");
    foreach my $step (0..6) {
        push @{$bubbles_anim{stick}}, my $img = add_image("balls/stick_effect_$step.png");
        $img_mini{$img} = add_image("balls/stick_effect_${step}-mini.png")
    }

    $shooter = add_image("shoot/shooter.png");
    foreach my $number (-$CANON_ROTATIONS_NB..$CANON_ROTATIONS_NB) {
        $canon{img}{$number} = add_image("shoot/base_$number.png");
        $img_mini{$canon{img}{$number}} = add_image("shoot/mini/base_${number}.png") ;
    }

    #- quantity of shifting needed (because of crop reduction)
    /(\S+) (\S+) (\S+)/ and $canon{data}{$1} = [ $2, $3 ] foreach cat_("$FPATH/gfx/shoot/data");
    /(\S+) (\S+) (\S+)/ and $canon{data_mini}{$1} = [ $2, $3 ] foreach cat_("$FPATH/gfx/shoot/mini/data");

    $malus_gfx{banane} = add_image('banane.png');
    $img_mini{$malus_gfx{banane}} = add_image('banane-mini.png');
    $malus_gfx{tomate} = add_image('tomate.png');
    $img_mini{$malus_gfx{tomate}} = add_image('tomate-mini.png');

    print_step('.'); 
    push @{$imgbin{paused}}, add_image("pause_$_.png") foreach 1..5;
    $imgbin{back_paused} = add_image('back_paused.png');
    $imgbin{lose} = add_image('lose_panel.png');
    $imgbin{win_panel_1player} = add_image('win_panel_1player.png');
    $imgbin{compressor_main} = add_image('compressor_main.png');
    $imgbin{compressor_ext} = add_image('compressor_ext.png');

    $imgbin{txt_1pgame_off}  = add_image('menu/txt_1pgame_off.png');
    $imgbin{txt_1pgame_over} = add_image('menu/txt_1pgame_over.png');
    $imgbin{txt_2pgame_off}  = add_image('menu/txt_2pgame_off.png');
    $imgbin{txt_2pgame_over} = add_image('menu/txt_2pgame_over.png');
    $imgbin{txt_netgame_off}  = add_image('menu/txt_netgame_off.png');
    $imgbin{txt_netgame_over} = add_image('menu/txt_netgame_over.png');
    $imgbin{txt_editor_off}  = add_image('menu/txt_editor_off.png');
    $imgbin{txt_editor_over} = add_image('menu/txt_editor_over.png');
    $imgbin{txt_fullscreen_off}  = add_image('menu/txt_fullscreen_off.png');
    $imgbin{txt_fullscreen_over} = add_image('menu/txt_fullscreen_over.png');
    $imgbin{txt_fullscreen_act_off}  = add_image('menu/txt_fullscreen_act_off.png');
    $imgbin{txt_fullscreen_act_over} = add_image('menu/txt_fullscreen_act_over.png');
    $imgbin{txt_keys_off}  = add_image('menu/txt_keys_off.png');
    $imgbin{txt_keys_over} = add_image('menu/txt_keys_over.png');
    $imgbin{txt_sound_off}  = add_image('menu/txt_sound_off.png');
    $imgbin{txt_sound_over} = add_image('menu/txt_sound_over.png');
    $imgbin{txt_sound_act_off}  = add_image('menu/txt_sound_act_off.png');
    $imgbin{txt_sound_act_over} = add_image('menu/txt_sound_act_over.png');
    $imgbin{txt_graphics_1_off}  = add_image('menu/txt_graphics_1_off.png');
    $imgbin{txt_graphics_1_over} = add_image('menu/txt_graphics_1_over.png');
    $imgbin{txt_graphics_2_off}  = add_image('menu/txt_graphics_2_off.png');
    $imgbin{txt_graphics_2_over} = add_image('menu/txt_graphics_2_over.png');
    $imgbin{txt_graphics_3_off}  = add_image('menu/txt_graphics_3_off.png');
    $imgbin{txt_graphics_3_over} = add_image('menu/txt_graphics_3_over.png');
    $imgbin{txt_highscores_off}  = add_image('menu/txt_highscores_off.png');
    $imgbin{txt_highscores_over} = add_image('menu/txt_highscores_over.png');
    $imgbin{void_panel} = add_image('menu/void_panel.png');
    $imgbin{version} = add_image('menu/version.png');
    $imgbin{blink} = add_image('menu/blink.png');
    $imgbin{left} = add_image('left.png');
    $imgbin{mp_ready_newgame} = add_image('pinguins/mp_ready_newgame.png');
    $imgbin{mp_waiting_newgame} = add_image('pinguins/mp_waiting_newgame.png');

    #- scrolling banner
    $imgbin{banner_artwork} = add_image('menu/banner_artwork.png');
    $imgbin{banner_soundtrack} = add_image('menu/banner_soundtrack.png');
    $imgbin{banner_cpucontrol} = add_image('menu/banner_cpucontrol.png');
    $imgbin{banner_leveleditor} = add_image('menu/banner_leveleditor.png');

    $MENUPOS{xpos_panel} = (640 - $imgbin{void_panel}->width) / 2;
    $MENUPOS{ypos_panel} = (480 - $imgbin{void_panel}->height) / 2;

    #- 1p and 2p menu images
    $imgbin{txt_1pmenu_play_all_levels_over} = add_image('menu/txt_play_all_levels_over.png');
    $imgbin{txt_1pmenu_play_all_levels_off} = add_image('menu/txt_play_all_levels_off.png');
    $imgbin{txt_1pmenu_pick_start_level_over} = add_image('menu/txt_pick_start_level_over.png');
    $imgbin{txt_1pmenu_pick_start_level_off} = add_image('menu/txt_pick_start_level_off.png');
    $imgbin{txt_1pmenu_play_random_levels_off} = add_image('menu/txt_play_random_levels_off.png');
    $imgbin{txt_1pmenu_play_random_levels_over} = add_image('menu/txt_play_random_levels_over.png');

    #- net game setup images
    $imgbin{back_netgame} = add_image('back_netgame.png');

    #- hiscore
    $imgbin{back_hiscores} = add_image('back_hiscores.png');
    $imgbin{hiscore_frame} = add_image('hiscore_frame.png');
    
    print_step('.'); 
    #- temporarily desactivate the intro storyboard because it's not finished yet
    #- $imgbin{frozen} = add_image('intro/txt_frozen.png');
    #- $imgbin{bubble} = add_image('intro/txt_bubble.png');
    #- $imgbin{intro_penguin_imgs}->{$_} = add_image("intro/intro_$_.png") foreach 1..19;

    local @PLAYERS = @ALL_PLAYERS;  #- load all images even if -so commandline option was passed
    iter_players {
	$imgbin{hurry}{$::p} = add_image("hurry_$::p.png");
	$pinguin{$::p}{normal} = [ map { add_image($_) } ("pinguins/base_$::p.png", map { "pinguins/base_$::p"."_extra_0$_.png" } (1..3)) ];
	$pinguin{$::p}{sleep} = [ add_image("pinguins/sleep_$::p.png") ];
	$pinguin{$::p}{left} = [ add_image("pinguins/move_left_$::p.png") ];
	$pinguin{$::p}{right} = [ add_image("pinguins/move_right_$::p.png") ];
	$pinguin{$::p}{action} = [ add_image("pinguins/action_$::p.png") ];
	$pinguin{$::p}{win} = [ map { add_image("pinguins/$::p"."_win_$_.png") } qw(1 2 3 4 5 6 7 8 6) ];
	$pinguin{$::p}{win_roll_back_index} = 4;
	$pinguin{$::p}{lose} = [ map { add_image("pinguins/$::p"."_loose_$_.png") } qw(1 2 3 4 5 6 7 8 9) ];
	$pinguin{$::p}{lose_roll_back_index} = 5;
	$pinguin{$::p}{win} = [ map { add_image("pinguins/$::p"."_win_$_.png") } qw(1 2 3 4 5 6 7 8 6) ];
	$pinguin{$::p}{walkright} = [ map { add_image("pinguins/$::p"."_dg_walk_0$_.png") } qw(1 2 3 4 5 6) ];
	$imgbin{win}{$::p} = add_image("win_panel_$::p.png");
	$pdata{$::p}{score} = 0;
    };
    print_step('] '); 

    $lev_number = 0;
    print_step("[Levels] "); 
    load_levelset("$FPATH/data/levels");

    if ($mixer eq 'SOUND_DISABLED') {
	$mixer_enabled = $mixer = undef;
    } else {
	$mixer_enabled = init_sound();
    }

    fb_c_stuff::init_effects($FPATH);

    print "Ready.\n";
}

sub open_level($) {
    my ($level) = @_;

    $level eq 'WON' and $level = $lev_number;

    @{$levels{$level}} or die "No such level or void level ($level).\n";
    foreach my $l (@{$levels{$level}}) {
	iter_players {
	    my $img = $l->{img_num} =~ /^\d+$/ ? $bubbles_images[$l->{img_num}] : $bubbles_anim{lose};
	    real_stick_bubble(create_bubble_given_img($img), $l->{cx}, $l->{cy}, $::p, 0);
	};
    }
}

sub grab_key($) {
    my ($unicode) = @_;
    my $keyp;

    do {
	$event->wait;
	if ($event->type == SDL_KEYDOWN) {
	    #$keyp = $unicode ? ($event->key_unicode || $event->key_sym) : $event->key_sym;
	    $keyp = $event->key_sym;
	}
    } while ($event->type != SDL_KEYDOWN);

    #- so that using "capital" letter should work
    if (member($keyp, SDLK_LSHIFT(), SDLK_RSHIFT())) {
        return grab_key($unicode);
    } else {
        return $keyp;
    }
}

sub display_highscores() {

    $imgbin{back_hiscores}->blit($apprects{main}, $app, $apprects{main});

    $display_on_app_disabled = 1;
    @PLAYERS = ('p1');
    %POS = %POS_1P;

    my $initial_high_posx = 90;
    my ($high_posx, $high_posy) = ($initial_high_posx, 68);
    my $high_rect = SDL::Rect->new('-x' => $POS{p1}{left_limit} & 0xFFFFFFFC, '-y' => $POS{p1}{top_limit} & 0xFFFFFFFC,
				   '-width' => ($POS{p1}{right_limit}-$POS{p1}{left_limit}) & 0xFFFFFFFC, -height => ($POS{p1}{'initial_bubble_y'}-$POS{p1}{top_limit}-10) & 0xFFFFFFFC);

    $font = SDL::Font->new("$FPATH/gfx/font-hi.png");
    my $centered_print = sub($$$) {
	my ($x, $y, $txt) = @_;
	$app->print($x+($imgbin{hiscore_frame}->width-SDL_TEXTWIDTH(uc($txt)))/2 - 6,
		    $y+$imgbin{hiscore_frame}->height - 8, uc($txt));
    };

    my $old_levelset = $loaded_levelset;

    foreach my $high (ordered_highscores()) {
	iter_players {
	    @{$sticked_bubbles{$::p}} = ();
	    @{$root_bubbles{$::p}} = ();
	    $pdata{$::p}{newrootlevel} = 0;
	    $pdata{$::p}{oddswap} = 0;
	};
	$imgbin{back_1p}->blit($high_rect, $background, $high_rect);

	# try to get it from the default-levelset. If we can't, default to the
	# last level in the default levelset
	if (!$high->{piclevel}) {
	    $loaded_levelset ne "$FPATH/data/levels" and load_levelset("$FPATH/data/levels");
        
	    # handle the case where the user has edited/created a levelset with more levels
	    # than the default levelset and then got a high score
	    if ($high->{level} > $lev_number) {
		open_level($lev_number);
	    } else {
		open_level($high->{level});
	    }
	} else {
	    # this is the normal case. just load the level that the file tells us
	    if ($loaded_levelset ne "$ENV{HOME}/.fbhighlevelshistory") {
		load_levelset("$ENV{HOME}/.fbhighlevelshistory");
	    }
	    open_level($high->{piclevel});
	}

	put_image($imgbin{hiscore_frame}, $high_posx - 7, $high_posy - 6);
	my $tmp = SDL::Surface->new(-width => $high_rect->width/4, -height => $high_rect->height/4,
                                    -depth => 32, -Amask => "0 but true")->display_format;
	fb_c_stuff::shrink($tmp->{-surface}, $background->display_format->{-surface}, 0, 0, $high_rect->{-rect}, 4);
        $tmp->blit(undef, $app, SDL::Rect->new(-x => $high_posx, '-y' => $high_posy));
	$centered_print->($high_posx, $high_posy,    $high->{name});
	$centered_print->($high_posx, $high_posy+20, $high->{level} eq 'WON' ? "WON!" : "LVL-".$high->{level});
	my $min = int($high->{time}/60);
	my $sec = int($high->{time} - $min*60); length($sec) == 1 and $sec = "0$sec";
	$centered_print->($high_posx, $high_posy+40, "$min'$sec''");
	$high_posx += 98;
	$high_posx > 550 and $high_posx = $initial_high_posx, $high_posy += 175;
	$high_posy > 440 and last;
    }
    load_levelset($old_levelset);
    $app->flip;
    $display_on_app_disabled = 0;

    $font = SDL::Font->new("$FPATH/gfx/font.png");
    $event->pump while ($event->poll != 0);
    grab_key(0);
}

sub keysym_to_char($) { my ($key) = @_; eval("$key eq SDLK_$_") and return uc($_) foreach @fbsyms::syms }

sub ask_from($) {
    my ($w) = @_;
    # $w->{intro} = [ 'text_intro_line1', 'text_intro_line2', ... ]
    # $w->{entries} = [ { q => 'question1?', a => \$var_answer1, f => 'flags' }, {...} ]   flags: ONE_CHAR
    # $w->{outro} = 'text_outro_uniline'
    # $w->{erase_background} = $background_right_one

    put_image($imgbin{void_panel}, $MENUPOS{xpos_panel}, $MENUPOS{ypos_panel});

    my $xpos;
    my $ypos = $MENUPOS{ypos_panel} + 5;

    foreach my $i (@{$w->{intro}}) {
	if ($i) {
	    my $xpos = (640-SDL_TEXTWIDTH($i))/2;
	    $app->print($xpos, $ypos, $i);
	}
	$ypos += 22;
    }

    $ypos += 3;

    my $ok = 1;
  entries:
    foreach my $entry (@{$w->{entries}}) {
	$xpos = (640-$imgbin{void_panel}->width)/2 + 120 - SDL_TEXTWIDTH($entry->{'q'})/2;
	$app->print($xpos, $ypos, $entry->{'q'});
	$app->flip;
	my $srect_mulchar_redraw = SDL::Rect->new(-width => $imgbin{void_panel}->width, -height => 30,
						 -x => $xpos + 140 - $MENUPOS{xpos_panel}, '-y' => $ypos - $MENUPOS{ypos_panel});
	my $drect_mulchar_redraw = SDL::Rect->new(-width => $imgbin{void_panel}->width, -height => 30,
						 -x => $xpos + 140, '-y' => $ypos);
	my $txt;
	while (1) {
	    my $k = grab_key($entry->{f} !~ 'ONE_CHAR');
	    $k == SDLK_ESCAPE and $ok = 0, last entries;
	    play_sound('typewriter');
	    if ($entry->{f} =~ 'ONE_CHAR' || $k != SDLK_RETURN) {
		my $x_echo = (640-$imgbin{void_panel}->width)/2 + 230;
		if ($entry->{f} =~ 'ONE_CHAR') {
		    $txt = $k;
		    $app->print($x_echo, $ypos, keysym_to_char($k));
		} else {
		    $k = keysym_to_char($k);
		    length($k) == 1 && length($txt) < 8 and $txt .= $k;
		    member($k, qw(BACKSPACE DELETE LEFT)) and $txt =~ s/.$//;
		    $imgbin{void_panel}->blit($srect_mulchar_redraw, $app, $drect_mulchar_redraw);
		    $app->print($x_echo, $ypos, $txt);
		}
		$app->flip;
	    }
	    $entry->{f} =~ 'ONE_CHAR' || $k == SDLK_RETURN and last;
	}
	$entry->{answer} = $txt;
	$ypos += 22;
    }

    if ($ok) {
	${$_->{a}} = $_->{answer} foreach @{$w->{entries}};
	$xpos = (640-SDL_TEXTWIDTH($w->{outro}))/2;
	$ypos = (480+$imgbin{void_panel}->height)/2 - 35;
	$app->print($xpos, $ypos, $w->{outro});
	$app->flip;
	play_sound('menu_selected');
	sleep 1;
    } else {
	play_sound('cancel');
    }

    exists $w->{erase_background} and erase_image_from($imgbin{void_panel}, $MENUPOS{xpos_panel}, $MENUPOS{ypos_panel}, $w->{erase_background});
    $app->flip;
    $event->pump while ($event->poll != 0);

    return $ok;
}

sub new_game() {
    print "\n\tnew_game\n";

    $display_on_app_disabled = 1;

    $TIME_APPEARS_NEW_ROOT = 11;
    $TIME_HURRY_WARN = 250;
    $TIME_HURRY_MAX = 375;

    my $backgr;
    if (is_mp_game()) {
	$backgr = $imgbin{back_mp};
	%POS = %POS_MP;
    } elsif (is_2p_game()) {
	$backgr = $imgbin{back_2p};
	%POS = %POS_2P;
    } elsif (is_1p_game()) {
	$backgr = $imgbin{back_1p};
	%POS = %POS_1P;
	$TIME_APPEARS_NEW_ROOT = 8;
	$TIME_HURRY_WARN = 400;
	$TIME_HURRY_MAX = 525;
	$pdata{$PLAYERS[0]}{score} = $levels{current} || "RANDOM";
    } else {
	die "oops";
    }

    $backgr->blit($apprects{main}, $background_orig, $apprects{main});
    $background_orig->blit($apprects{main}, $background, $apprects{main});

    iter_players {
	$actions{$::p}{$_} = 0 foreach qw(left right fire center);
	$angle{$::p} = $PI/2;
	@{$sticked_bubbles{$::p}} = ();
	@{$malus_bubble{$::p}} = ();
	@{$root_bubbles{$::p}} = ();
	@{$falling_bubble{$::p}} = ();
	@{$exploding_bubble{$::p}} = ();
	@{$chains{$::p}{falling_chained}} = ();
	%{$chains{$::p}{chained_bubbles}} = ();
	$launched_bubble{$::p} = undef;
	$sticking_bubble{$::p} = undef;
	$pdata{$::p}{$_} = 0 foreach qw(newroot newroot_prelight oddswap malus hurry newrootlevel);
	$pdata{$::p}{state} = 'ingame';
	$pdata{$::p}{ping_right}{img} = 0;
	$pdata{$::p}{ping_right}{state} = 'normal';
	$apprects{$::p} = SDL::Rect->new('-x' => $POS{$::p}{left_limit}, '-y' => $POS{$::p}{top_limit},
					 -width => $POS{$::p}{right_limit}-$POS{$::p}{left_limit}, -height => $POS{$::p}{'initial_bubble_y'}-$POS{$::p}{top_limit});

        $pdata{$::p}{left} = 0;
        if (is_distant_player($::p)) {
            $pdata{$::p}{still_game_messages} = 1;
            $pdata{$::p}{ready4newgame} = 0;
        }
    };

    print_scores($background);

    is_1p_game() and print_compressor();

    if ($levels{current}) {
	open_level($levels{current});
    } else {
	foreach my $cy (0 .. 4) {
	    foreach my $cx (0 .. (6 + even($cy))) {
                my $num = int(rand(@bubbles_images));
                if (is_mp_game()) {
                    check_mp_connection();
                    $num = mp_propagate("bubble|$cx|$cy", $num);
                }
                my $b = create_bubble_given_img_num($num);
                real_stick_bubble($b, $cx, $cy, $PLAYERS[0], 0);
                if (!is_1p_game()) {
                    iter_players_but_first {
                        real_stick_bubble(create_bubble_given_img($b->{img}), $cx, $cy, $::p, 0);
                    };
                }
	    }
	}
    }

    my ($next_num, $tobe_num);
    do { $next_num = int(rand(@bubbles_images)) } while (!validate_nextcolor($next_num, $PLAYERS[0]));
    do { $tobe_num = int(rand(@bubbles_images)) } while (!validate_nextcolor($tobe_num, $PLAYERS[0]));
    if (is_mp_game()) {
        check_mp_connection();
        $next_num = mp_propagate("nextbubble", $next_num);
        $tobe_num = mp_propagate("tobe_launchedbubble", $tobe_num);
    }
    $next_bubble{$PLAYERS[0]} = create_bubble_given_img_num($next_num);
    generate_new_bubble($PLAYERS[0], $tobe_num);
    if (!is_1p_game()) {
        iter_players_but_first {
            $next_bubble{$::p} = create_bubble_given_img_num($next_num);
            generate_new_bubble($::p, $tobe_num);
        };
    }

    if ($graphics_level == 1) {
	$background->blit($apprects{main}, $app, $apprects{main});
	$app->flip;
    } else {
	fb_c_stuff::effect($app->{-surface}, $background->display_format->{-surface});
    }

    $display_on_app_disabled = 0;

    $event->pump while ($event->poll != 0);
    $pdata{state} = 'game';

    $direct = undef;

    if (is_mp_game()) {
        if (is_leader()) {
            fb_net::gsend('!synchro');
        }
        check_mp_connection();
        my $m = fb_net::grecv_get1msg();
        if ($m->{msg} ne '!synchro') {
            print "Network protocol error.\n";
            return;
        }
        iter_distant_players {
            $pdata{$::p}{ping} = $frame;
        };
    }
}

sub choose_1p_game_mode() {

    my @ordered_names = qw(play_all_levels pick_start_level play_random_levels);
    my $active_menu = 0;

    my $redraw = sub {
        my $menu_ypos_spacer = $imgbin{txt_1pmenu_play_all_levels_over}->height + 15;
        my $menu_xpos = $MENUPOS{xpos_panel} + ($imgbin{void_panel}->width - $imgbin{txt_1pmenu_play_all_levels_over}->width)/2; 
        my $menu_ypos = $MENUPOS{ypos_panel} + 75;

        my $draw_element = sub {
            my ($name, $mode) = @_;
            my %name2ypos = (play_all_levels => $menu_ypos,
                             pick_start_level => $menu_ypos + $menu_ypos_spacer,
                             play_random_levels => $menu_ypos + 2 * $menu_ypos_spacer);
            my $img_name = 'txt_1pmenu_' . $name . '_' . $mode;
            put_image($imgbin{$img_name}, $menu_xpos, $name2ypos{$name});
        };

        my $img = $imgbin{void_panel};
        my $save if 0;
        my $drect = SDL::Rect->new(-width => $img->width, -height => $img->height,
                                   -x => $MENUPOS{xpos_panel}, '-y' => $MENUPOS{ypos_panel});
        if ($save) {
            $save->blit($rects{img}, $app, $drect);
        } else {
            $save = SDL::Surface->new(-width => $img->width, -height => $img->height,
                                      -depth => 32, -Amask => "0 but true");
            $app->blit($drect, $save, $rects{$img});
        }
        put_image($img, $MENUPOS{xpos_panel}, $MENUPOS{ypos_panel});

        my $title = "START 1P GAME MENU";
        my $ypos = $MENUPOS{ypos_panel} + 10;
        my $xpos = (640 - SDL_TEXTWIDTH($title)) / 2;
        $app->print($xpos, $ypos, $title);

        foreach (@ordered_names) {
            $_ ne $ordered_names[$active_menu] and $draw_element->($_, 'off');
        }

        $draw_element->($ordered_names[$active_menu], 'over');

        $app->flip();
    };

    while (1) {
        $redraw->();
        $event->pump;
        if ($event->poll != 0) {
            if ($event->type == SDL_KEYDOWN) {
                my $k = $event->key_sym;
                if ($k == SDLK_RETURN() || $k == SDLK_KP_ENTER()) {
                    my $cancel;
                    if ($ordered_names[$active_menu] eq 'pick_start_level') {
                        if ($levels{current}) {
                            choose_levelset(1) or $cancel = 1;
                        }
                    } elsif ($ordered_names[$active_menu] eq 'play_random_levels') {
                        #- set the random command line parameter
                        $levels{current} = undef;
                    }
                    $cancel or return 1;
                } elsif ($event->key_sym == SDLK_ESCAPE) {
                    $levels{current} = undef;
                    return;
                } elsif ($k == SDLK_DOWN()) {
                    if ($active_menu < @ordered_names - 1) {
                        $active_menu++;
                        play_sound('menu_change');
                    }
                } elsif ($k == SDLK_UP()) {
                    if ($active_menu > 0) {
                        $active_menu--;
                        play_sound('menu_change');
                    }
                }
            }
        }
    }
}


our $smg_lineheight = 22;
our $smg_startx = 78;
our $smg_starty = 30;
our $smg_starty_chat = 316;
our $smg_starty_players = $smg_starty_chat + $smg_lineheight;

sub erase_line($$;$$) {
    my ($pos, $background, $xpos, $width) = @_;
    my $drect = SDL::Rect->new(-width => $width || 640, -height => $smg_lineheight, -x => $xpos || 0, '-y' => $pos);
    $background->blit($drect, $app, $drect);
}

sub smg_printstatus {
    my (@messages) = @_;
    my $y = 370;
    foreach (0..3) {
        erase_line($y, $imgbin{back_netgame});
        $app->print($smg_startx, $y, $messages[$_]);
        $y += $smg_lineheight;
    }
    $app->flip();
}

sub smg_servers() {
    smg_printstatus("CONTACTING MASTER SERVER...");
    my $serverlist = fb_net::get_server_list();
    my @servers;
    if ($serverlist) {
        foreach my $line (split /\n/, $serverlist) {
            if ($line =~ /^(\S+) (\S+)$/) {
                push @servers, { host => $1, port => $2 };
            } else {
                print STDERR "Unrecognized line in serverlist:\n\t$line\n";
            }
        }
    } else {
        smg_printstatus("UNABLE TO DOWNLOAD SERVER LIST!",
                        "VERIFY YOUR NETWORK SETUP OR RETRY LATER.");
        grab_key(0);
    }
    return @servers;
}

our @smg_status_messages;

sub smg_choose_server(@) {
    my (@servers) = @_;

    erase_line($smg_starty_chat, $imgbin{back_netgame});     #- if we return from choose_game
    erase_line($smg_starty_players, $imgbin{back_netgame});  #-

    my @sorted_servers;
    my $redraw = sub {
        my $y = $smg_starty;
        foreach my $server (@sorted_servers) {
            erase_line($y, $imgbin{back_netgame});
            if ($server->{selected}) {
                put_image($malus_gfx{tomate}, 56, $y);
            }
            $app->print($smg_startx, $y, uc($server->{host} . ':' . $server->{port}));
            $app->print(300, $y, $server->{ping} == -1 ? '*** INCOMPATIBLE SERVER ***'
                               : $server->{ping} == 0  ? '*** CURRENTLY DOWN ***'
                                                       : "AVAIL PLAYERS:$server->{players}   PING:$server->{ping}");
            $y += $smg_lineheight;
        }
        $app->flip();
    };

    my $reping;
    my $ping = sub {
        foreach my $server (@servers) {
            if (!$server->{disabled}) {
                $reping or smg_printstatus('CONNECTING TO: ' . uc($server->{host} . ':' . $server->{port}));
                my $ping = fb_net::connect($server->{host}, $server->{port});
                if ($ping <= 0) {
                    $server->{disabled} = 1;
                } else {
                    ($server->{players}) = fb_net::list();
                }
                $server->{ping} = $ping;
                fb_net::disconnect();
            }
        }
        my ($down, $available) = partition { $_->{disabled} } @servers;
        @sorted_servers = ((sort { $a->{ping} <=> $b->{ping} } @$available), @$down);
        $redraw->();
    };

    $ping->();
    if (every { $_->{disabled} } @servers) {
        smg_printstatus("ALL SERVERS CURRENTLY DOWN!",
                        "PLEASE RETRY LATER.");
        grab_key(0);
        return;
    }
    if (@sorted_servers && every { !$_->{selected} } @sorted_servers) {
        $sorted_servers[0]->{selected} = 1;
    }
    smg_printstatus("PLEASE CHOOSE A SERVER");
    $redraw->();

    while (1) {
        $reping++;
        $reping % (5*20) == 0 and $ping->();

        $event->pump;
        if ($event->poll != 0) {
            if ($event->type == SDL_KEYDOWN) {
                my $k = $event->key_sym;

                if ($k == SDLK_ESCAPE()) {
                    return 0;

                } elsif ($k == SDLK_DOWN()) {
                    if (@sorted_servers) {
                        each_index {
                            if ($sorted_servers[$::i]->{selected}
                                && $::i < @sorted_servers - 1
                                && !$sorted_servers[$::i+1]->{disabled}) {
                                $sorted_servers[$::i]->{selected} = 0;
                                $sorted_servers[$::i+1]->{selected} = 1;
                                play_sound('menu_change');
                                goto done;
                            }
                        } @sorted_servers;
                      done:
                    }

                } elsif ($k == SDLK_UP()) {
                    if (@sorted_servers && !$sorted_servers[0]->{selected}) {
                        each_index {
                            if ($sorted_servers[$::i]->{selected}) {
                                $sorted_servers[$::i]->{selected} = 0;
                                $sorted_servers[$::i-1]->{selected} = 1;
                                play_sound('menu_change');
                            }
                        } @sorted_servers;
                    }

                } elsif ($k == $KEYS->{misc}{fs}) {
                    $fullscreen = !$fullscreen;
                    $app->fullscreen;

                } elsif ($k == SDLK_RETURN() || $k == SDLK_KP_ENTER()) {
                    play_sound('menu_selected');
                    goto ok_smg_choose_server;
                }
            }
            $redraw->();
        } else {
            fb_c_stuff::fbdelay(50);
        }
    }

  ok_smg_choose_server:
    my $y = $smg_starty;
    foreach (@servers) {
        erase_line($y, $imgbin{back_netgame});
        $y += $smg_lineheight;
    }
    @smg_status_messages = ();

    foreach my $server (@servers) {
        if ($server->{selected}) {
            my $ping = fb_net::connect($server->{host}, $server->{port});
            $ping or return smg_choose_server(@servers);
            last;
        }
    }

    return 1;
}

sub smg_add_status_msg($) {
    push @smg_status_messages, uc($_[0]);
    @smg_status_messages > 4 and shift @smg_status_messages;
}

sub smg_verify_command($) {
    my ($sent_command) = @_;
    my ($command, $message);
    do {
        my $msg = fb_net::readline_();
        ($command, $message) = fb_net::decode_msg($msg);
        # FIXME: should not drop PUSH messages
    } while ($command eq 'PUSH');
    if ($command ne $sent_command || $message ne 'OK') {
        return $message;
    } else {
        return;
    }
}

sub update_typed_chat($$$) {
    my ($typed_chat, $k, $maxlen) = @_;
    $k = keysym_to_char($k);
    my %trivial_map = ('SPACE' => ' ', 'PERIOD' => '.', 'COMMA' => ',',
                       'QUOTE' => "'", 'SLASH' => '/', 'MINUS' => '-');
    $k = $trivial_map{$k} || $k;
    if (length($k) == 1 && length($typed_chat) < $maxlen) {
        $typed_chat .= $k;
        play_sound('typewriter');
    } elsif (member($k, qw(BACKSPACE DELETE LEFT))) {
        $typed_chat =~ s/.$//;
        play_sound('typewriter');
    }
    return $typed_chat;
}

sub smg_choose_game() {
    my @actions = ({ name => 'CHAT', action => 'CHAT', selected => 1 },
                   { name => 'CREATE NEW GAME', action => 'CREATE' });
    my $max_actions = 10;

    my $curaction = sub {
        my $cur;
        each_index {
            if ($actions[$::i]->{selected}) {
                $cur = $::i;
                goto curaction_done;
            }
        } @actions;
      curaction_done:
        return $actions[$cur];
    };

    my $state = 'game_select';

    my $typed_chat;
    my $erase = sub {
        my $y = $smg_starty;
        foreach (1 .. $max_actions) {
            erase_line($y, $imgbin{back_netgame});
            $y += $smg_lineheight;
        }
    };
    my $redraw = sub {
        $erase->();
        my $y = $smg_starty;
        foreach my $action (@actions) {
            if ($action->{selected}) {
                put_image($malus_gfx{tomate}, 56, $y);
            }
            $app->print($smg_startx, $y, $action->{name});
            $y += $smg_lineheight;
        }
        erase_line($smg_starty_chat, $imgbin{back_netgame});
        if ($curaction->() && $curaction->()->{name} eq 'CHAT') {
            $app->print($smg_startx, $smg_starty_chat, "SAY: $typed_chat");
        }
        smg_printstatus(@smg_status_messages);
        $app->flip();
    };

    my $list = sub {
        $state eq 'game_select' or return;
        my ($free, @games) = fb_net::list();
        my ($join, $rest) = partition { $_->{name} =~ /^JOIN/ } @actions;
        $_->{ok} = 0 foreach @$join;
      listgames:
        foreach my $players (@games) {
            if (@$players < 5) {
                my $name = 'JOIN: ' . uc(join(',', @$players));
                foreach my $line (@$join) {
                    if ($line->{name} eq $name) {
                        $line->{ok} = 1;
                        next listgames;
                    }
                }
                push @$join, { name => $name, action => 'JOIN', join => $players->[0], ok => 1 };
            }
        }
        @actions = (@$rest, grep { $_->{ok} } @$join);
        if (!any { $_->{selected} } @actions) {
            $actions[0]{selected} = 1;
        }
        erase_line($smg_starty_players, $imgbin{back_netgame});
        $app->print($smg_startx, $smg_starty_players, "AVAILABLE PLAYERS: $free");
        $redraw->();
    };

    my $mynick = substr($ENV{USER}, 0, 8);
    my $need4update;
    my $relist;
    $list->();

    while (1) {
        $relist++;
        $relist % (3*20) == 0 and $list->();

        $event->pump;
        if ($event->poll != 0) {
            if ($event->type == SDL_KEYDOWN) {
                my $k = $event->key_sym;

                if ($k == SDLK_ESCAPE()) {
                    fb_net::disconnect();
                    return 0;

                } elsif ($k == SDLK_DOWN()) {
                    each_index {
                        if ($actions[$::i]->{selected}
                            && $::i < @actions - 1) {
                            $actions[$::i]->{selected} = 0;
                            $actions[$::i+1]->{selected} = 1;
                            play_sound('menu_change');
                            goto done2;
                        }
                    } @actions;
                  done2:

                } elsif ($k == SDLK_UP()) {
                    if (!$actions[0]->{selected}) {
                        each_index {
                            if ($actions[$::i]->{selected}) {
                                $actions[$::i]->{selected} = 0;
                                $actions[$::i-1]->{selected} = 1;
                                play_sound('menu_change');
                            }
                        } @actions;
                    }

                } elsif ($k == SDLK_RETURN() || $k == SDLK_KP_ENTER()) {
                    if ($curaction->()->{action} eq 'CHAT' && length($typed_chat) > 0) {
                        play_sound('menu_selected');
                        fb_net::send_("TALK ($mynick) $typed_chat");
                        $typed_chat = '';
                    }

                    if (member($curaction->()->{action}, 'CREATE', 'JOIN')) {
                        my $suffix = 1;
                        my $answer;
                        while (1) {
                            my $message = $curaction->()->{action} eq 'CREATE' ? "CREATE $mynick"
                                                                               : "JOIN ".$curaction->()->{join}." $mynick";
                            fb_net::send_($message);
                            $answer = smg_verify_command($curaction->()->{action});
                            if ($answer eq 'NICK_IN_USE') {
                                $suffix++;
                                $mynick = "$ENV{USER}$suffix";
                            } else {
                                last;
                            }
                        }
                        if ($answer) {
                            smg_add_status_msg("*** ERROR in ".$curaction->()->{join}.": $answer");
                        } else {
                            $erase->();
                            @actions = ({ name => 'CHAT', action => 'CHAT', selected => 1 },
                                        { name => 'START GAME!', action => 'START' });
                            $state = 'wait_for_start';
                            $need4update = 1;
                            @smg_status_messages = ();
                        }
                    }
                            
                    if ($curaction->()->{action} eq 'START') {
                        fb_net::send_('START');
                        my $answer = smg_verify_command('START');
                        if ($answer) {
                            smg_add_status_msg("*** CAN'T START GAME: $answer");
                        } else {
                            goto start_game;
                        }
                    }
                    

                } else {
                    if ($curaction->()->{action} eq 'CHAT') {
                        $typed_chat = update_typed_chat($typed_chat, $k, 32);
                    
                    } elsif ($k == $KEYS->{misc}{fs}) {
                        $fullscreen = !$fullscreen;
                        $app->fullscreen;
                    }
                }

            }
            $redraw->();
        } else {
            fb_c_stuff::fbdelay(50);
        }

        while (my $msg = fb_net::readline_ifdata()) {
            my ($command, $message) = fb_net::decode_msg($msg);
            if ($command eq 'PUSH') {
                if ($message =~ /^TALK: (.*)/) {
                    smg_add_status_msg($1);
                    play_sound('typewriter');
                } elsif ($message =~ /^JOINED: (.*)/) {
                    smg_add_status_msg("*** $1 JOINED THE GAME!");
                    play_sound('newroot_solo');
                } elsif ($message =~ /^PARTED: (.*)/) {
                    smg_add_status_msg("*** $1 LEFT THE GAME...");
                    play_sound('newroot_solo');
                } elsif ($message =~ /^START: (.*)/) {
                    smg_add_status_msg("*** $1 STARTED THE GAME AND IS WAITING!");
                    play_sound('newroot');
                } elsif ($message =~ /^STOP: (.*)/) {
                    smg_add_status_msg("*** $1 ABORTED STARTING, CANCELLING GAME...");
                    fb_net::send_("PART");
                    my $answer = smg_verify_command('PART');
                    $redraw->();
                    play_sound('cancel');
                    fb_c_stuff::fbdelay(2000);
                    while (my $msg = fb_net::readline_ifdata()) {
                        my ($command, $message) = fb_net::decode_msg($msg);
                        if ($command ne 'PUSH' || $message !~ /^PARTED:/) {
                            print "unexpected message received: $msg\n";
                        }
                    }
                    return smg_choose_game();
                } else {
                    print "unrecognized message received: $msg\n";
                }
                $need4update = 1;
            } else {
                print "non-push received!? $msg\n";
            }
        }

        if (!fb_net::isconnected()) {
            smg_add_status_msg('*** LOST CONNECTION TO SERVER, ABANDONING...');
            @actions = ();
            $redraw->();
            play_sound('cancel');
            fb_c_stuff::fbdelay(2000);
            return 0;
        }

        if ($need4update) {
            if ($state ne 'game_select') {
                fb_net::send_('STATUS');
                my $answer = smg_verify_command('STATUS');
                erase_line($smg_starty_players, $imgbin{back_netgame});
                $app->print($smg_startx, $smg_starty_players, "PLAYERS IN GAME: ".uc($answer));
            }
            $redraw->();
            $need4update = 0;
        }
    }

  start_game:
    $erase->();

    return $mynick;
}

sub smg_start_game($) {
    my ($mynick) = @_;

    smg_add_status_msg('WAITING FOR OTHER PLAYERS...');

    @PLAYERS = qw(p1);

    my $redraw = sub {
        smg_printstatus(@smg_status_messages);
        $app->flip();
    };
    $redraw->();

    while (1) {

        $event->pump;
        if ($event->poll != 0) {
            if ($event->type == SDL_KEYDOWN) {
                my $k = $event->key_sym;

                if ($k == SDLK_ESCAPE()) {
                    fb_net::send_('STOP');
                    my $answer = smg_verify_command('STOP');
                    if ($answer) {
                        smg_add_status_msg("*** CAN'T STOP GAME: $answer");
                    } else {
                        smg_add_status_msg("*** ABORTED STARTING GAME...");
                        $redraw->();
                        fb_c_stuff::fbdelay(2000);
                        return 0;
                    }

                } elsif ($k == $KEYS->{misc}{fs}) {
                    $fullscreen = !$fullscreen;
                    $app->fullscreen;
                }
            }
            $redraw->();
        } else {
            fb_c_stuff::fbdelay(50);
        }

        while (my $msg = fb_net::readline_ifdata()) {
            my ($command, $message) = fb_net::decode_msg($msg);
            if ($command eq 'PUSH') {
                if ($message =~ /^START: (.*)/) {
                    smg_add_status_msg("*** $1 ALSO STARTED THE GAME...");
                    play_sound('newroot');

                } elsif ($message =~ /^TALK: (.*)/) {
                    smg_add_status_msg($1);
                    play_sound('typewriter');

                } elsif ($message =~ /^STOP: (.*)/ || $message =~ /^PARTED: (.*)/) {
                    smg_add_status_msg("*** $1 ABORTED STARTING, CANCELLING GAME...");
                    $redraw->();
                    fb_c_stuff::fbdelay(2000);
                    return 0;

                } elsif ($message =~ /^GAME_CAN_START: (.*)/) {
                    my $msg = $1;
                    my @mappings;
                    while ($msg) {
                        my $id = substr($msg, 0, 1);
                        $msg = substr($msg, 1);
                        my ($nick, undef, $rest) = $msg =~ /([^,]+)(,(.*))?/;
                        $msg = $rest;
                        push @mappings, { id => $id, nick => $nick };
                    }
                    delete $pdata{$_}{id} foreach @ALL_PLAYERS;
                    foreach my $m (@mappings) {
                        my $player;
                        if ($m->{nick} eq $mynick) {
                            $player = 'p1';
                        } else {
                            foreach (@ALL_PLAYERS) {
                                /rp/ or next;
                                exists $pdata{$_}{id} or $player ||= $_;
                            }
                            push @PLAYERS, $player;
                        }
                        $pdata{$player}{id} = $m->{id};
                        $pdata{$player}{nick} = uc($m->{nick});
                        $pdata{id2p}{$m->{id}} = $player;
                    }
                    return 1;
                    
                } else {
                    print "unrecognized message received: $msg\n";
                }
            } else {
                print "non-push received!? $msg\n";
            }
            $redraw->();
        }

        if (!fb_net::isconnected()) {
            smg_add_status_msg('*** LOST CONNECTION TO SERVER, ABANDONING...');
            $redraw->();
            play_sound('cancel');
            fb_c_stuff::fbdelay(2000);
            return 0;
        }
    }
}

sub setup_mp_game() {

    $font = SDL::Font->new("$FPATH/gfx/font2.png");

    $imgbin{back_netgame}->blit($apprects{main}, $app, $apprects{main});

    if (!fb_net::isconnected()) {
        @smg_status_messages = ();
        if ($gameserver) {
            my ($host, $port) = $gameserver =~ /(\S+):(\S+)/;
            fb_net::connect($host, $port) or goto master_server;
        } else {
          master_server:
            #- 1. contact master server
            my @servers if 0;
            @servers = smg_servers() or return;
            
          choose_server:
            #- 2. let user choose server
            smg_choose_server(@servers) or return;
        }
            
    } else {
        @PLAYERS = reverse ssort { $pdata{$_}{score} } @PLAYERS;
        if ($pdata{$PLAYERS[0]}{score} > $pdata{$PLAYERS[1]}{score}) {
            smg_add_status_msg("*** GAME FINISHED, WINNER: $pdata{$PLAYERS[0]}{nick}");
        } else {
            smg_add_status_msg('*** GAME FINISHED, DRAW GAME!');
        }
        smg_add_status_msg('*** ' . join(', ', map { "$pdata{$_}{nick}: $pdata{$_}{score}" } @PLAYERS));
    }

  choose_game:
    #- 3. let user choose/create game
    my $mynick = smg_choose_game() or goto choose_server;

    #- 4. start game waiting for other players, and receiving id/nick bindings
    smg_start_game($mynick) or goto choose_game;

    $pdata{$_}{score} = 0 foreach @PLAYERS;

    return 1;
}

sub new_game_once {

    if (!$direct) {
        if (is_1p_game()) {
            choose_1p_game_mode() or return;
        }
        if (is_2p_game() && $graphics_level > 1) {
            my $answ;
            ask_from({ intro => [ '2-PLAYER GAME', '', '', 'ENABLE CHAIN-REACTION?', '' ],
                       entries => [ { 'q' => 'Y OR N?', 'a' => \$answ, f => 'ONE_CHAR' } ],
                       outro => 'ENJOY THE GAME!' }) or return;
            $chainreaction = $answ == SDLK_y; #;;
        }
        if (is_mp_game()) {
            setup_mp_game() or return;
        }
    }
    play_music(is_1p_game() ? 'main1p' : 'main2p');
    return 1;
}

sub lvl_cmp($$) { $_[0] eq 'WON' ? ($_[1] eq 'WON' ? 0 : 1) : ($_[1] eq 'WON' ? -1 : $_[0] <=> $_[1]) }

sub ordered_highscores() { return sort { lvl_cmp($b->{level}, $a->{level}) || $a->{time} <=> $b->{time} } @$HISCORES }

sub handle_new_hiscores() {
    is_1p_game() && $levels{current} or return;

    my @ordered = ordered_highscores();
    my $worst = pop @ordered;

    my $total_seconds = ($app->ticks - $time_1pgame)/1000;

    if (@$HISCORES == 10 && (lvl_cmp($levels{current}, $worst->{level}) == -1
			     || lvl_cmp($levels{current}, $worst->{level}) == 0 && $total_seconds > $worst->{time})) {
	return;
    }

    play_sound('applause');
    append_highscore_level();

    my %new_entry;
    $new_entry{level} = $levels{current};
    $new_entry{time} = $total_seconds;
    $new_entry{piclevel} = count_highscorehistory_levels();
    ask_from({ intro => [ 'CONGRATULATIONS!', "YOU HAVE A HIGHSCORE!", '' ],
	       entries => [ { 'q' => 'YOUR NAME?', 'a' => \$new_entry{name} } ],
	       outro => 'GREAT GAME!',
	       erase_background => $background,
	     });

    return if $new_entry{name} eq '';

    push @$HISCORES, \%new_entry;
    if (@$HISCORES == 11) {
	my @high = ordered_highscores();
	pop @high;
	$HISCORES = \@high;
    }

    output($hiscorefile, Data::Dumper->Dump([$HISCORES], [qw(HISCORES)]));
    display_highscores();
}

# append the new highscore to the .fbhighlevelshistory
sub append_highscore_level() {

    my $row_numb = 0;
    my $lvl = 1;

    my @contents;

    foreach my $line (cat_($loaded_levelset)) {
	if ($line !~ /\S/) {
	    if ($row_numb) {
		$lvl++;
		$row_numb = 0;
            } 
        } else {
            $row_numb++;
            $lvl == ($levels{current} eq 'WON' ? (keys %levels)-1 : $levels{current})
	      and push @contents, $line;
        }
    }

    append_to_file("$ENV{HOME}/.fbhighlevelshistory", @contents, "\n\n");
}

sub count_highscorehistory_levels() {
    my $cnt = 0;
    my $row_numb = 0;
    foreach my $line (cat_("$ENV{HOME}/.fbhighlevelshistory")) {
	if ($line !~ /\S/) {
	    if ($row_numb) {
		$cnt++;
		$row_numb = 0;
            } 
        } else {
            $row_numb++;
        }
    }
    return $cnt;
} 


#- ----------- mainloop ---------------------------------------------------

sub maingame() {
    my $synchro_ticks = $app->ticks;

    handle_graphics(\&erase_image);
    update_game();
    handle_graphics(\&put_image);
    $frame++;

    $app->update(@update_rects);
    @update_rects = ();

    my $to_wait = $TARGET_ANIM_SPEED - ($app->ticks - $synchro_ticks);
    $to_wait > 0 and fb_c_stuff::fbdelay($to_wait);
}


#- ----------- intro stuff ------------------------------------------------

sub intro_plus_menu() {

    my %storyboard = (
		      sleeping => {
				   start => { type => 'time', value => 0 },
				   type => 'penguin',
				   animations => [ qw(1 2 3 4 5 6 7 6 5 4 3 2) ],
				  },
		      music => { start => { type => 'time', value => 1 } },
		      bubble_fall1 => { start => { type => 'synchro', value => 0x01 },
					type => 'bubble_falling', img => 2, xpos => 200, xaccel => -1.5 },
		      bubble_fall2 => { start => { type => 'synchro', value => 0x02 },
					type => 'bubble_falling', img => 3, xpos => 350, xaccel => 1 },
		      bubble_fall3 => { start => { type => 'synchro', value => 0x03 },
					type => 'bubble_falling', img => 4, xpos => 400, xaccel => 2 },
		      eyes_moving => {
				      start => { type => 'synchro', value => 0x21 },
				      type => 'penguin',
				      animations => [ qw(8 9 10 11 12 11 10 9) ],
				  },
		      arms_moving => {
				      start => { type => 'synchro', value => 0x22 },
				      type => 'penguin',
				      animations => [ qw(12 13 14 15 14 13) ],
				  },
		      fear => {
			       start => { type => 'synchro', value => 0x31 },
			       type => 'penguin',
			       animations => [ qw(15 16 17 18 19 18 17 16) ],
			      },
		      txt_frozen_arriving => {
					      start => { type => 'synchro', value => 0x31 },
					      type => 'bitmap_animation',
					      img => $imgbin{frozen},
					      finalpos => { x => 300, 'y' => 100 },
					      factor => 1,
					     },
		      txt_bubble_arriving => {
					      start => { type => 'synchro', value => 0x32 },
					      type => 'bitmap_animation',
					      img => $imgbin{bubble},
					      finalpos => { x => 340, 'y' => 155 },
					      factor => 4,
					     },
		     );

    my %sb_params = (
		     animation_speed => 20
		    );


    my $start_menu;
    my ($slowdown_number, $slowdown_frame);

    return menu(0);   #- temporarily desactivate the intro storyboard because it's not finished yet

    if ($mixer_enabled && $mixer) {
	play_music('intro');
	$mixer->pause_music;
	my $back_start = SDL::Surface->new(-name => "$FPATH/gfx/intro/back_intro.png");
	$back_start->blit($apprects{main}, $app, $apprects{main});
	$app->flip;

	my $penguin;
	my @bubbles_falling;
	my @bitmap_animations;

	my $anim_step = -1;
	my $start_time = $app->ticks;
	my $current_time = $start_time;

	while (!$start_menu) {
	    my $synchro_ticks = $app->ticks;

	    my $current_time_ = int(($app->ticks - $start_time)/1000);
	    my $anim_step_ = fb_c_stuff::get_synchro_value();

	    if ($anim_step_ != $anim_step || $current_time_ != $current_time) {
		$anim_step = $anim_step_;
		$current_time = $current_time_;
		printf "Anim step: %12s Time: <$current_time>\n", sprintf "<0x%02x>", $anim_step;

		foreach my $evt (keys %storyboard) {
		    next if $storyboard{$evt}->{already};
		    if ($storyboard{$evt}->{start}->{type} eq 'time' && $storyboard{$evt}->{start}->{value} <= $current_time
			|| $storyboard{$evt}->{start}->{type} eq 'synchro' && $storyboard{$evt}->{start}->{value} eq $anim_step) {
			$storyboard{$evt}->{already} = 1;
			print "*** Starting <$evt>\n";
			$evt eq 'music' and $mixer->resume_music;
			if ($storyboard{$evt}->{type} eq 'penguin') {
			    $penguin = { animations => $storyboard{$evt}->{animations},
					 current_anim => 0,
					 anim_step => $sb_params{animation_speed} };
			}
			if ($storyboard{$evt}->{type} eq 'bubble_falling') {
			    push @bubbles_falling, { img => $bubbles_images[$storyboard{$evt}->{img}], 'y' => 0, speed => 3,
						     x => $storyboard{$evt}->{xpos}, xaccel => $storyboard{$evt}->{xaccel} };
			}
			if ($storyboard{$evt}->{type} eq 'bitmap_animation') {
			    push @bitmap_animations, { img => $storyboard{$evt}->{img}, 'y' => 0,
						       x => $storyboard{$evt}->{finalpos}->{x},
						       finaly => $storyboard{$evt}->{finalpos}->{'y'},
						       factor => $storyboard{$evt}->{factor},
						     };
			}
		    }
		}

		$anim_step == 0x09 and $start_menu = 1;
	    }

	    if ($penguin) {
		$penguin->{anim_step}++;
		if ($penguin->{anim_step} >= $sb_params{animation_speed}) {
		    my $img_number = ${$penguin->{animations}}[$penguin->{current_anim}];
#		    erase_image_from($imgbin{intro_penguin_imgs}->{$img_number}, 260, 293, $back_start);
		    $penguin->{anim_step} = 0;
		    $penguin->{current_anim}++;
		    $penguin->{current_anim} == @{$penguin->{animations}} and $penguin->{current_anim} = 0;
		    $img_number = ${$penguin->{animations}}[$penguin->{current_anim}];
#		    put_image($imgbin{intro_penguin_imgs}->{$img_number}, 260, 293);
		}
	    }

	    foreach my $b (@bubbles_falling) {
		erase_image_from($b->{img}, $b->{x}, $b->{'y'}, $back_start);
		$b->{'x'} += $b->{xaccel};
		$b->{'y'} += $b->{speed};
		if ($b->{'y'} >= 360 && !$b->{already_rebound}) {
		    $b->{already_rebound} = 1;
		    $b->{'y'} = 2*360 - $b->{'y'};
		    $b->{speed} *= -0.5;
		}
		$b->{speed} += $FREE_FALL_CONSTANT;
		$b->{kill} = $b->{'y'} > 470;
		$b->{kill} or put_image($b->{img}, $b->{x}, $b->{'y'});
	    }
	    @bubbles_falling = grep { !$_->{kill} } @bubbles_falling;

#	    erase_image_from($_->{img}, $_->{x}, $_->{'y'}, $back_start) foreach @bitmap_animations;
	    foreach my $b (@bitmap_animations) {
		foreach (0..$slowdown_frame) {
		    $b->{'y'} = $b->{'finaly'} - 200*cos(3*$b->{step})/exp($b->{step}*$b->{step});
		    $b->{step} += 0.015 * $b->{factor};
		}
	    }
	    $slowdown_frame = 0;
#	    put_image($_->{img}, $_->{x}, $_->{'y'}) foreach @bitmap_animations;

	    $app->update(@update_rects);
	    @update_rects = ();

	    my $to_wait = $TARGET_ANIM_SPEED - ($app->ticks - $synchro_ticks);
	    if ($to_wait > 0) {
		$app->delay($to_wait);
	    } else {
#		print "slow by: <$to_wait>\n";
		$slowdown_number += -$to_wait;
		if ($slowdown_number > $TARGET_ANIM_SPEED) {
		    $slowdown_frame = int($slowdown_number / $TARGET_ANIM_SPEED);
		    $slowdown_number -= $slowdown_frame * $TARGET_ANIM_SPEED;
#		    print "skip frames: <$slowdown_frame>\n";
		}
	    }

	    $event->pump;
	    $event->poll != 0 && $event->type == SDL_KEYDOWN && member($event->key_sym, (SDLK_RETURN, SDLK_SPACE, SDLK_KP_ENTER, SDLK_ESCAPE))
		and $start_menu = 2;

	}
    }


#    if ($start_menu == 1) {
#	my $bkg = SDL::Surface->new(-width => $app->width, -height => $app->height, -depth => 32, -Amask => '0 but true');
#	$app->blit($apprects{main}, $bkg, $apprects{main});
#	menu(1, $bkg);
#    } else {
	menu(1);
#    }
}


#- ----------- menu stuff -------------------------------------------------

sub menu {
    my ($from_intro, $back_from_intro) = @_;

    handle_new_hiscores();

    if (!$from_intro) {
        $music{current} ne 'intro' and play_music('intro', 8);
    }

    my $back_start;
    my $display_menu = sub {
	$back_start->blit($apprects{main}, $app, $apprects{main});
	put_image($imgbin{version}, 17, 432);
    };

    if (!$from_intro || !$back_from_intro) {
	$back_start = $imgbin{backstartfull};
	$display_menu->();
    } else {
	$back_start = $back_from_intro;
    }

    my $invalidate_all;

    my $menu_start_sound = sub {
	if (!$mixer_enabled && !$mixer && !init_sound()) {
	    return 0;
	} else {
	    $mixer_enabled = 1;
	    play_music('intro', 8);
	    return 1;
	}
    };

    my $menu_stop_sound = sub {
	if ($mixer_enabled && $mixer && $mixer->playing_music) {
	    $app->delay(10) while $mixer->fading_music;   #- mikmod will deadlock if we try to fade_out while still fading in
	    $mixer->playing_music and $mixer->fade_out_music(500); $app->delay(450);
	    $app->delay(10) while $mixer->playing_music;  #- mikmod will segfault if we try to load a music while old one is still fading out
	}
	$mixer_enabled = undef;
	return 1;
    };

    my $menu_display_highscores = sub {
	display_highscores();

	$display_menu->();
	$app->flip;
	$invalidate_all->();
    };

    my $change_keys = sub {
	ask_from({ intro => [ 'PLEASE ENTER NEW KEYS' ],
		   entries => [
			       { 'q' => 'RIGHT-PL/LEFT?',  'a' => \$KEYS->{p2}{left},  f => 'ONE_CHAR' },
			       { 'q' => 'RIGHT-PL/RIGHT?', 'a' => \$KEYS->{p2}{right}, f => 'ONE_CHAR' },
			       { 'q' => 'RIGHT-PL/FIRE?',  'a' => \$KEYS->{p2}{fire},  f => 'ONE_CHAR' },
			       { 'q' => 'RIGHT-PL/CENTER?',  'a' => \$KEYS->{p2}{center},  f => 'ONE_CHAR' },
			       { 'q' => 'LEFT-PL/LEFT?',  'a' => \$KEYS->{p1}{left},  f => 'ONE_CHAR' },
			       { 'q' => 'LEFT-PL/RIGHT?', 'a' => \$KEYS->{p1}{right}, f => 'ONE_CHAR' },
			       { 'q' => 'LEFT-PL/FIRE?',  'a' => \$KEYS->{p1}{fire},  f => 'ONE_CHAR' },
			       { 'q' => 'LEFT-PL/CENTER?',  'a' => \$KEYS->{p1}{center},  f => 'ONE_CHAR' },
			       { 'q' => 'TOGGLE FULLSCREEN?', 'a' => \$KEYS->{misc}{fs}, f => 'ONE_CHAR' },
			      ],
		   outro => 'THANKS!',
		   erase_background => $back_start
		 });
	$invalidate_all->();
    };

    my $launch_editor = sub {
        SDL::ShowCursor(1);
        FBLE::init_setup('embedded', $app);
        FBLE::handle_events();
        SDL::ShowCursor(0);
	$display_menu->();
        $app->flip;
        $invalidate_all->();
    };

    my $doblink = sub {
        my ($is_on) = @_;
        my ($xpos, $ypos) = (557, 87);
        my $img = $imgbin{blink};
        my $drect = SDL::Rect->new(-width => $img->width, -height => $img->height, -x => $xpos, '-y' => $ypos);
        if ($is_on) {
            put_image($img, $xpos, $ypos);
        } else {
            $back_start->blit($drect, $app, $drect);
        }
	$app->update($drect);
    };

    my ($MENU_XPOS, $MENU_FIRSTY, $SPACING) = (56, 30, 51);
    my %menu_ypos = ( '1pgame' =>      $MENU_FIRSTY,
		      '2pgame' =>      $MENU_FIRSTY +     $SPACING,
		      'netgame'=>      $MENU_FIRSTY + 2 * $SPACING,
		      'editor' =>      $MENU_FIRSTY + 3 * $SPACING,
#		      'fullscreen' =>  $MENU_FIRSTY + 3 * $SPACING,
		      'graphics' =>    $MENU_FIRSTY + 4 * $SPACING,
		      'sound' =>       $MENU_FIRSTY + 5 * $SPACING,
		      'keys' =>        $MENU_FIRSTY + 6 * $SPACING,
		      'highscores' =>  $MENU_FIRSTY + 7 * $SPACING,
		  );
    my %menu_entries = ( '1pgame' => { pos => 1, type => 'rungame',
				       run => sub { @PLAYERS = ('p1'); $levels{current} = 1; $chainreaction = 0; $time_1pgame = $app->ticks } },
			 '2pgame' => { pos => 2, type => 'rungame',
				       run => sub { @PLAYERS = qw(p1 p2); $levels{current} = undef; } },
			 'netgame'=> { pos => 3, type => 'rungame',
				       run => sub { @PLAYERS = qw(p1 rp1); $levels{current} = undef; } },
			 'editor' => { pos => 4, type => 'run', run => sub { $launch_editor->(); } },
#			 'fullscreen' => { pos => 4, type => 'toggle',
#					   act => sub { $fullscreen = 1; $app->fullscreen },
#					   unact => sub { $fullscreen = 0; $app->fullscreen },
#					   value => $fullscreen },
			 'graphics' => { pos => 5, type => 'range', valuemin => 1, valuemax => 3,
					 change => sub { $graphics_level = $_[0] }, value => $graphics_level },
			 'sound' => { pos => 6, type => 'toggle',
				      act => sub { $menu_start_sound->() },
				      unact => sub { $menu_stop_sound->() },
				      value => $mixer_enabled },
			 'keys' => { pos => 7, type => 'run',
				     run => sub { $change_keys->() } },
			 'highscores' => { pos => 8, type => 'run',
					   run => sub { $menu_display_highscores->() } },
		       );
    my $current_pos if 0; $current_pos ||= 1;
    my @menu_invalids;
    $invalidate_all = sub { push @menu_invalids, $menu_entries{$_}->{pos} foreach keys %menu_entries };

    my $menu_update = sub {
	@update_rects = ();
	foreach my $m (keys %menu_entries) {
	    member($menu_entries{$m}->{pos}, @menu_invalids) or next;
	    my $txt = "txt_$m";
	    $menu_entries{$m}->{type} eq 'toggle' && $menu_entries{$m}->{value} and $txt .= "_act";
	    $menu_entries{$m}->{type} eq 'range' and $txt .= "_$menu_entries{$m}->{value}";
	    $txt .= $menu_entries{$m}->{pos} == $current_pos ? '_over' : '_off';
	    erase_image_from($imgbin{$txt}, $MENU_XPOS, $menu_ypos{$m}, $back_start);
	    put_image($imgbin{$txt}, $MENU_XPOS, $menu_ypos{$m});
	}
	@menu_invalids = ();
	$app->update(@update_rects);
    };

    $app->flip;
    $invalidate_all->();
    $menu_update->();
    $event->pump while ($event->poll != 0);

    my $start_game = 0;
    my ($BANNER_START, $BANNER_SPACING) = (720, 80);
    my %banners = (artwork => $BANNER_START,
		   soundtrack => $BANNER_START + $imgbin{banner_artwork}->width + $BANNER_SPACING,
		   cpucontrol => $BANNER_START + $imgbin{banner_artwork}->width + $BANNER_SPACING
		                 + $imgbin{banner_soundtrack}->width + $BANNER_SPACING,
		   leveleditor => $BANNER_START + $imgbin{banner_artwork}->width + $BANNER_SPACING
                                 + $imgbin{banner_soundtrack}->width + $BANNER_SPACING
                                 + $imgbin{banner_cpucontrol}->width + $BANNER_SPACING);
    my ($BANNER_MINX, $BANNER_MAXX, $BANNER_Y) = (81, 292, 443);
    my $banners_max = $banners{leveleditor} - (640 - ($BANNER_MAXX - $BANNER_MINX)) + $BANNER_SPACING;
    my $banner_rect = SDL::Rect->new(-width => $BANNER_MAXX-$BANNER_MINX, -height => 30, '-x' => $BANNER_MINX, '-y' => $BANNER_Y);

    while (!$start_game) {
	my $synchro_ticks = $app->ticks;

	$graphics_level > 1 and $back_start->blit($banner_rect, $app, $banner_rect);

	$event->pump;
	if ($event->poll != 0) {
	    if ($event->type == SDL_KEYDOWN) {
		my $keypressed = $event->key_sym;
		if (member($keypressed, (SDLK_DOWN, SDLK_RIGHT)) && $current_pos < max(map { $menu_entries{$_}->{pos} } keys %menu_entries)) {
		    $current_pos++;
		    push @menu_invalids, $current_pos-1, $current_pos;
		    play_sound('menu_change');
		}
		if (member($keypressed, (SDLK_UP, SDLK_LEFT)) && $current_pos > 1) {
		    $current_pos--;
		    push @menu_invalids, $current_pos, $current_pos+1;
		    play_sound('menu_change');
		}

		if (member($keypressed, (SDLK_RETURN, SDLK_SPACE, SDLK_KP_ENTER))) {
		    play_sound('menu_selected');
		    push @menu_invalids, $current_pos;
		    foreach my $m (keys %menu_entries) {
			if ($menu_entries{$m}->{pos} == $current_pos) {
			    if ($menu_entries{$m}->{type} =~ /^run/) {
				$menu_entries{$m}->{run}->();
				$menu_entries{$m}->{type} eq 'rungame' and $start_game = 1;
			    }
			    if ($menu_entries{$m}->{type} eq 'toggle') {
				$menu_entries{$m}->{value} = !$menu_entries{$m}->{value};
				if ($menu_entries{$m}->{value}) {
				    $menu_entries{$m}->{act}->() or $menu_entries{$m}->{value} = 0;
				} else {
				    $menu_entries{$m}->{unact}->() or $menu_entries{$m}->{value} = 1;
				}
			    }
			    if ($menu_entries{$m}->{type} eq 'range') {
				$menu_entries{$m}->{value}++;
				$menu_entries{$m}->{value} > $menu_entries{$m}->{valuemax}
				  and $menu_entries{$m}->{value} = $menu_entries{$m}->{valuemin};
				$menu_entries{$m}->{change}->($menu_entries{$m}->{value});
			    }
			}
		    }
		}

                if ($keypressed == SDLK_ESCAPE) {
		    exit 0;
		}
	    }
            if ($event->type == SDL_QUIT) {
                exit 0;
            }
	    $menu_update->();
	}

	if ($graphics_level > 1) {
	    my $banner_pos if 0;
	    $banner_pos ||= 670;
	    foreach my $b (keys %banners) {
		my $xpos = $banners{$b} - $banner_pos;
		my $image = $imgbin{"banner_$b"};

		$xpos > $banners_max/2 and $xpos = $banners{$b} - ($banner_pos + $banners_max);

		if ($xpos < $BANNER_MAXX && $xpos + $image->width >= 0) {
		    my $irect = SDL::Rect->new(-width => min($image->width+$xpos, $BANNER_MAXX-$BANNER_MINX),
                                               -height => $image->height, -x => -$xpos);
		    $image->blit($irect, $app, SDL::Rect->new(-x => $BANNER_MINX, '-y' => $BANNER_Y));
		}
	    }
	    $banner_pos++;
	    $banner_pos >= $banners_max and $banner_pos = 1;
            $app->update($banner_rect);

            my $blink if 0;
            my $reblink if 0;
            $reblink and $reblink--;
            if (!$blink) {
                if (rand() < 0.002 || $reblink == 1) {
                    $doblink->(1);
                    $blink = 4;
                }
            } else {
                $blink--;
                if ($blink == 0) {
                    $doblink->(0);
                    rand() < 0.25 and $reblink = 4;
                }
            }
	}

	my $to_wait = $TARGET_ANIM_SPEED - ($app->ticks - $synchro_ticks);
	$to_wait > 0 and $app->delay($to_wait);
    }

    #- for $KEYS, try hard to keep SDLK_<key> instead of integer value in rcfile
    my $KEYS_;
    foreach my $p (keys %$KEYS) {
	foreach my $k (keys %{$KEYS->{$p}}) {
	    eval("$KEYS->{$p}->{$k} eq SDLK_$_") and $KEYS_->{$p}->{$k} = "SDLK_$_" foreach @fbsyms::syms;
	}
    }
    my $dump = Data::Dumper->Dump([$fullscreen, $graphics_level, $KEYS_], [qw(fullscreen graphics_level KEYS)]);
    $dump =~ s/'SDLK_(\w+)'/SDLK_$1/g;
    output($rcfile, $dump);

    iter_players {
       !is_1p_game() and $pdata{$::p}{score} = 0;
    };
}


#- ----------- editor stuff --------------------------------------------

sub choose_levelset() {
    my ($choose_level) = @_;

    my @levelsets = sort glob("$FBLEVELS/*");

    if ($direct_levelset) {
        load_levelset("$FBLEVELS/$direct_levelset");
        $direct_levelset = '';

    } elsif (!@levelsets && !$choose_level) {
        # no .fblevels directory or void directory, just return and let the
        # game continue (means that the level editor has never been opened)

    } else {
	
	if (@levelsets <= 1 && !$choose_level) {
	    load_levelset($levelsets[0]);
	} else {
            #if they are choosing the start level, we need to ensure the default
            #levelset is in $FBLEVELS or the dialog won't display properly
            if ($choose_level) {
                -d $FBLEVELS or mkdir $FBLEVELS;
                -d $FBLEVELS or die "Can't create $FBLEVELS directory.\n";
                -f "$FBLEVELS/default-levelset" or cp_af("$FPATH/data/levels", "$FBLEVELS/default-levelset");
            }
            
	    FBLE::init_app('embedded', $app);
            FBLE::create_play_levelset_dialog($choose_level, $levels{current});
	    SDL::ShowCursor(1);
            my @game_info = FBLE::handle_events();
            @game_info or return;
            load_levelset("$FBLEVELS/$game_info[0]");
            $levels{current} = $game_info[1];
	    SDL::ShowCursor(0);
	}
    }

    return 1;
}


#- ----------- main -------------------------------------------------------

init_game();

$direct or intro_plus_menu();

while (!new_game_once()) { menu() }
new_game();


while (1) {
    eval { maingame() };
    if ($@) {
	if ($@ =~ /^new_game/) {
	    new_game();
	} elsif ($@ =~ /^quit/) {
            print "quitted\n";
            if (is_mp_game() && fb_net::reconnect() && new_game_once()) {
                new_game();
            } else {
                do { menu() } while (!new_game_once());
                new_game();
            }
	} else {
	    die;
	}
    }
}
